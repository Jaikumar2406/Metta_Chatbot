Introduction to evaluation in MeTTa

Main concepts
Atoms and knowledge graphs
MeTTa (Meta Type Talk) is a multi-paradigm language for declarative and functional computations over knowledge (meta)graphs.

Every MeTTa program lives inside of a particular Atomspace (or just Space if we don't insist on a particular internal representation). Atomspace is a part of the OpenCog (Hyperon) software ecosystem and it is essentially a knowledge database with the associated query engine to fetch and manipulate that knowledge. MeTTa programs can contain both factual knowledge and rules or functional code to perform reasoning on knowledge including programs themselves making the language fully self-reflective. One can draw an analogy with Prolog, which programs can also be considered as a knowledge base content, but with less introspective and more restrictive representation.

In an Atomspace, an Atom is a fundamental building block of all the data. In the context of graph representation, an Atom can be either a node or a link. In an Atomspace as metagraph, links can connect not only nodes, but other links, that is, they connect atoms, and they can connect any number of atoms (in contrast to ordinary graphs). In MeTTa as a programming language, atoms play the role of terms.

In the context of AI, Atoms can represent anything from objects, to concepts, to processes, functions or relationships. This enables the creation of rich, complex models of knowledge and reasoning.

Atom kinds and types
There are 4 kinds of Atoms in MeTTa:

Symbol, which represents some idea or concept. Two symbols having the same name are considered equal and representing the same concept. Names of symbols can be arbitrary strings. Nearly anything can be a symbol, e.g., A, f, known?, replace-me, ≱, etc.
Expression, which can encapsulate other atoms including other expressions. Basic MeTTa syntax is Scheme-like, e.g. (f A), (implies (human Socrates) (mortal Socrates)), etc.
Variable, which is used to create patterns (expressions with variables). Such patterns can be matched against other atoms to assign some specific binding to their variables. Variables are syntactically distinguished by a leading $, e.g. $x, $_, $my-argument, which tells the parser to convert a symbol to a variable. Patterns could be (Parent $x $y), (Implies (Human $x) (Mortal $x)), (:- (And (Implies $x $y) (Fact $x)) $y), or any other symbolic expression with variables. Such patterns get meaning when they are matched against expressions in the Atomspace.
Grounded, which represents sub-symbolic data in the Atomspace. It may contain any binary object, for example operation (including deep neural networks), collection or value. Grounded value type creators can define custom type, execution and matching logic for the value. There are some grounded atoms in the standard library to deal with numbers or strings, e.g. (+ 1 2) is an expression composed of a grounded atom +, which refers to an arithmetic operation, and 1 and 2, which are grounded atoms containing specific values. Adding custom grounded atoms is a standard way for extending MeTTa and its interoperability.
Symbol, Variable, Grounded can be considered as nodes, while Expression can be considered as a generalized link. This interpretation of atoms plays an important role in MeTTa applications and Hyperon as a cognitive architecture, but is not essential for understanding MeTTa as a programming language.

MeTTa has optional typing, which is close enough to gradual dependent types, although with some peculiarities. %Undefined% is used for untyped expressions, while other types are represented as custom symbols and expressions. Symbol, Variable, Grounded, and Expression are metatypes, which can be used to analyze MeTTa programs by themselves. They are subtypes of Atom.

Special symbols
There is a small number of built-in symbols which determine how a MeTTa program will be evaluated:

Equality symbol =
defines evaluation rules for expressions and can be read as “can be evaluated as” or “can be reduced to”.
Colon symbol :
is used for type declarations.
Arrow symbol ->
defines type restrictions for evaluable expressions.
These atoms are of Symbol metatype, and do not refer to particular binary objects unlike Grounded atoms, but they are processed by the interpreter in a special way.

Basic evaluation
MeTTa programs
Programs in MeTTa consist of a number of atoms (mostly expressions, but individual symbols or grounded atoms can also be put there). A MeTTa script is a textual representation of the program, which is parsed atom-by-atom, and put into a program Space.

In particular, binary objects wrapped into grounded atoms are constructed from their textual representation in the course of parsing. For example, + and 1.05 will be turned into grounded atoms containing corresponding operation and value. Particular grounded atoms and their textual representation is not a part of the core MeTTa language, but is defined in modules (both built-in and custom). How modules and grounded atoms are introduced is discussed in another tutorial.

If a programmer wants some atom to be evaluated immediately instead of adding it to the Space, ! should be put before it. The result of evaluation will not be added to the Space, but will be included into the output result of the whole program.

MeTTa scripts can also have comments, starting with ;, which will be ignored by the parser.

In the following program, the first two atoms will be added to the program space, while the next two expressions will be immediately evaluated and appear in the output.


; This line will be ignored.
Hello ; This symbol will be added to the Space
(Hello World) ; This expression will also be added
! (+ 1 2) ; This expression will be immediatedly evaluated
! (Hi there) ; as well as this one
Output
[3]
[(Hi there)]
If an expression starts with a grounded atom containing an operation, this operation is executed on the other elements of the tuple acting as its arguments. (+ 1 2) is naturally evaluated to 3.

At the same time, (Hi there) is evaluated to itself, because Hi is not a grounded operation, but just a custom symbol. It acts similar to a data constructor in Haskell (more on this in another tutorial). Let us consider how to do computations over symbolic expressions in MeTTa.

Equalities
For a symbolic expression in MeTTa to be evaluated into something different from itself, an equality should be defined. Equality expressions work similar to function definitions in other languages. There is a number of important differences, though.

Let us consider a few examples.

A nullary function simply returns its body

(= (h) (Hello world))
! (h)
Output
[(Hello world)]
Some functions can accept only specific values of its argument. When this argument is passed, the right-hand side of the corresponding equality is returned

(= (only-a A) (Input A is accepted))
! (only-a A)
! (only-a B)
Output
[(Input A is accepted)]
[(only-a B)]
Note that (only-a B) is not reduced. In MeTTa, functions should not be total, and there is no hard boundary between a function and a data constructor. For example, consider this program:


! (respond me)
(= (respond me) (OK, I will respond))
! (respond me)
Output
[(respond me)]
[(OK, I will respond)]
The first (respond me) will remain unchanged, while the second one will be transformed.

Functions can have variables as parameters, just like in other languages.

(= (duplicate $x) ($x $x))
! (duplicate A)
! (duplicate 1.05)
Output
[(A A)]
[(1.05 1.05)]
The passed arguments replace corresponding variables in the right-hand part of the equality.

Its arguments can be expressions with some structure

(= (swap (Pair $x $y)) (Pair $y $x))
! (swap (Pair A B)) ; evaluates to (Pair B A)
Output
[(Pair B A)]
One may notice that this feature is similar to pattern matching in functional languages:


(= (Cdr (Cons $x $xs)) $xs)
! (Cdr (Cons A (Cons B Nil))) ; outputs (Cons B Nil)
Output
[(Cons B Nil)]
But it is more general, because the structure of patterns can be arbitrary. In particular, patterns can contain the same variable encountered multiple times.


(= (check ($x $y $x)) ($x $y))
! (check (B A B)) ; reduced to (B A)
! (check (B A A)) ; not reduced
Output
[(B A)]
[(check (B A A))]
Functions can have multiple (nondeterministic) results. The following code will output both 0 and 1

(= (bin) 0)
(= (bin) 1)
! (bin) ; both 0 and 1
Output
[0, 1]
Note that equations for functions are not mutually exclusive, and the following code will output two results (not only catched) in the last case


(= (f special-value) catched)
(= (f $x) $x)
! (f A) ; A
! (f special-value) ; both catched and special-value
Output
[A]
[catched, special-value]
Most importantly, variables can also be passed when calling a function, unlike imperative or functional languages. This will result in returning corresponding right-hand sides of equalities.

(= (brother Mike) Tom)
(= (brother Sam) Bob)
! (brother $x) ; just Tom and Bob are returned
! ((brother $x) is the brother of $x) ; the binding for $x is not lost
Output
[Tom, Bob]
[(Bob is the brother of Sam), (Tom is the brother of Mike)]
All these features are implemented using one mechanism, which is discussed later.

Evaluation chaining
The result of the function is evaluated further both for symbolic and grounded operation:

(= (square $x) (* $x $x))
! (square 3)
Output
[9]
Here, (square 3) is first reduced to (* 3 3), which, in turn, is evaluated to 9 by calling the grounded operation *.

In the following example, Second deconstructs the input list and returns Car for its tail, which is evaluated further


(= (Car (Cons $x $xs)) $x)
(= (Second (Cons $x $xs)) (Car $xs))
! (Second (Cons A (Cons B Nil))) ; outputs B
Output
[B]
Arguments of functions will typically be evaluated before the function is called. How this behavior can be controlled is discussed in a separate tutorial. The following examples should be pretty straightforward:

! (* (+ 1 2) (- 8 3)) ; 15
(= (square $x) (* $x $x))
! (square (+ 2 3)) ; 25
(= (triple $x) ($x $x $x))
(= (grid3x3 $x) (triple (triple $x)))
! (grid3x3 (square (+ 1 2))) ; ((9 9 9) (9 9 9) (9 9 9))
Output
[15]
[25]
[((9 9 9) (9 9 9) (9 9 9))]
This behavior is not different from other, especially functional, languages.

Passing results of nondeterministic functions to other functions (both deterministic and nondeterministic) cause the outer functions to be evaluated on each result. Consider the following examples:

; nondeterministic function
(= (bin) 0)
(= (bin) 1)
; deterministic triple
(= (triple $x) ($x $x $x))
! (triple (bin)) ; (0 0 0) and (1 1 1)
; nondeterministic pair
(= (bin2) ((bin) (bin)))
! (bin2) ; (0 0), (0 1), (1 0), (1 1)
; deterministic summation
(= (sum ($x $y)) (+ $x $y))
(= (sum ($x $y $z)) (+ $x (+ $y $z)))
! (sum (triple (bin))) ; 0, 3
! (sum (bin2)) ; 0, 1, 1, 2
; nondeterministic increment
(= (inc-flip $x) (+ 0 $x))
(= (inc-flip $x) (+ 1 $x))
! (inc-flip 1) ; 1, 2
! (inc-flip (bin)) ; 0, 1, 1, 2
Output
[(1 1 1), (0 0 0)]
[(0 0), (0 1), (1 0), (1 1)]
[0, 3]
[2, 1, 1, 0]
[1, 2]
[1, 2, 0, 1]
(triple (bin)) produces only two results, bevause (bin) is evaluated first and then passed to triple, while (bin2) produces four results, because each (bin) in its body is evaluated independently. Deterministic sum simply processes each nondeterministic value of its argument, while inc-flip doubles the number of input values.

Recursion and control
Basic recursion
A natural way to represent repetitive computations in MeTTa is recursion like in traditional functional languages, especially for processing recursive data structures. Let us consider a very basic recursive function, which calculates the number of elements in the list.


(= (length ()) 0)
(= (length (:: $x $xs))
   (+ 1 (length $xs)))
! (length (:: A (:: B (:: C ()))))
Output
[3]
The function has two cases, which are mutually exclusive de facto, and act as a conditional control structure. The base case returns 0 for an empty list (). Recursion itself takes place inside the second equality, in which length is defined via itself on the deconstructed parameter.

Notice that we didn't define the recursive data structure (list) here, and used arbitrary atoms (:: and ()) as data constructors. length can be called on anything, e.g. (length (hello world)), but this expression will simply be not reduced, because there are no suitable equalities for it. You can write your own version of length for other Cons and Nil instead of :: and ():

metta sandbox
Output
[(length (Cons A (Cons B (Cons C Nil))))]
If a function expects specific subset of all possible expressions as input, types for corresponding atoms should be defined. However, we focus here on the basic evaluation process itself and leave types for another tutorial.

Higher order functions
Higher-order functions is a powerful abstraction, which naturally appears in MeTTa. Consider the following code:


(= (apply-twice $f $x)
   ($f ($f $x)))
(= (square $x) (* $x $x))
(= (duplicate $x) ($x $x))
! (apply-twice square 2) ; 16
! (apply-twice duplicate 2) ; ((2 2) (2 2))
! (apply-twice 1 2) ; (1 (1 2))
Output
[16]
[((2 2) (2 2))]
[(1 (1 2))]
apply-twice takes a function as its first parameter and applies it twice to its second parameter. In fact, it doesn't really care if it is a function or not. It simply constructs a corresponding expression for further evaluation.

Passing functions into recursive functions is very convenient for processing various collections. Consider the following basic example


(= (map $f ()) ())
(= (map $f (:: $x $xs))
   (:: ($f $x) (map $f $xs)))
(= (square $x) (* $x $x))
(= (twice $x) (* $x 2))
! (map square (:: 1 (:: 2 (:: 3 ())))) ; (:: 1 (:: 4 (:: 9 ())))
! (map twice (:: 1 (:: 2 (:: 3 ())))) ; (:: 2 (:: 4 (:: 6 ())))
! (map A (:: 1 (:: 2 (:: 3 ())))) ; (:: (A 1) (:: (A 2) (:: (A 3) ())))
Output
[(:: 1 (:: 4 (:: 9 ())))]
[(:: 2 (:: 4 (:: 6 ())))]
[(:: (A 1) (:: (A 2) (:: (A 3) ())))]
map transforms a list by applying a given function (or constructor) to each element. There is a rich toolset of higher-order functions in functional programming. They are covered in another tutorial.

Conditional statements
Let us imagine that we want to implement the factorial operation. If we want to use grounded arithmetics, we will not be able to use pattern matching to deconstruct a grounded number and distinguish the base and recursive cases. We can write (= (fact 0) 1), but we cannot just write (= (fact $x) (* $x (fact (- $x 1)))). However, we can use if, which works much like if-then-else construction in any other language. Consider the following code


(= (factorial $x)
   (if (> $x 0)
       (* $x (factorial (- $x 1)))
       1))
! (factorial 5) ; 120
Output
[120]
(factorial $x) will be reduced to (* $x (factorial (- $x 1))) if (> $x 0) is True, and to 1 otherwise.

It should be noted that if doesn't evaluate all its arguments, but "then" and "else" branches are evaluated only when needed. factorial wouldn't work otherwise, although this should be more obvious from the following code, which will not execute the infinite loop


(= (loop) (loop)) ; this is an infinite loop 
! (if True Success (loop)) ; Success
Output
[Success]
Application of if looks like as an ordinary function application, and if is indeed implemented in pure MeTTa as a function. How it is done is discussed in another tutorial.

Another conditional statement in MeTTa is case, which pattern-matches the given atom against a number of patterns sequentially in a mutually exclusive way. A different version of the factorial operation can be implemented with it:


(= (factorial $x)
   (case $x
     ((0 1)
      ($_ (* $x (factorial (- $x 1)))))
   )
)
! (factorial 5) ; 120
Output
[120]
In contrast to if, case doesn't check logical conditions but performs pattern matching similar to application of a function with several equality definitions. Thus, their usage is somewhat different. For example, if one wants to zip two lists, it is convenient to distinguish two cases - when both lists are empty, and both lists are not empty. But when two lists are of different lengths, there will a situation when neither of these cases will be applicable, and the expression will not be reduced. Try to run this code:

metta sandbox
Output
[(:: (A 1) (:: (B 2) ()))]
[(:: (A 1) (zip (:: B ()) ()))]
The non-matchable part remains unreduced. Of course, adding two equalities for (zip (:: $x $xs) ()) and (zip () (:: $y $ys)) could be used (you can try to add them in the above code), and it would be a more preferable way in some cases. However, using case here could be more convenient:


(= (zip $list1 $list2)
   (case ($list1 $list2)
         (((() ()) ())
          (((:: $x $xs) (:: $y $ys)) (:: ($x $y) (zip $xs $ys)))
          ($else ERROR)
         )
   )
)
! (zip (:: A (:: B ())) (:: 1 (:: 2 ()))) ; (:: (A 1) (:: (B 2) ()))
! (zip (:: A (:: B ())) (:: 1 ())) ; (:: (A 1) ERROR)
Output
[(:: (A 1) (:: (B 2) ()))]
[(:: (A 1) ERROR)]

Free variables and nondeterminism again, recursively
A piece of logic
We have already encountered if, which reduces to different expressions depending on whether its first argument is True or False. They are returned by such grounded operations as > or ==. There are also such common logical operations as and, or, not in MeTTa (see the stdlib tutorial for more information). Things start to get interesting, when we pass free variables into logical expressions.

Let us consider the following program.

; Some facts as very basic equalities
(= (croaks Fritz) True)
(= (eats_flies Fritz) True)
(= (croaks Sam) True)
(= (eats_flies Sam) False)
; If something croaks and eats flies, it is a frog.
; Note that if either (croaks $x) or (eats_flies $x)
; is false, (frog $x) is also false.
(= (frog $x)
   (and (croaks $x)
        (eats_flies $x)))
! (if (frog $x) ($x is Frog) ($x is-not Frog))
; (green $x) is true if (frog $x) is true,
; otherwise it is not calculated.
(= (green $x)
   (if (frog $x) True (empty)))
! (if (green $x) ($x is Green) ($x is-not Green))

Output
[(Sam is-not Frog), (Fritz is Frog)]
[(Fritz is Green)]

There are some facts about Fritz and Sam, and there is a general rule about frogs. Just asking whether (frog $x) is True, we can infer that Fritz is a Frog, while Sam is not a Frog (detailed analysis of how it works is given in another tutorial).

(green $x) is defined in such a way that it is True when (frog $x) is True. However, if (frog $x) is False, it returns (empty) (which is evaluated to an empty set of results, which is equivalent to not defining a function on the corresponding data). Running the above code reveals that Fritz is green, but we cannot say whether Sam is green or not.

Make the replacement in the above code with the naive version of (green $x).


(= (green $x)
   (if (frog $x) True (empty)))
(= (green $x) (frog $x))
This will result in (Sam is-not Green) to appear, which shows that (= (green $x) (frog $x)) is not the same as logical implication even with boolean return values, although it is not precisely the same as equivalence (more on this in another tutorial).

You can also try to add (= (eats_flies Tod) True) into the set of facts. (green Tod) can be evaluated only partially (particular behavior is not fixed and might be different for different versions of MeTTa).

Recursion with nondeterminism
Let us generalize generation of random binary pairs to binary lists of a given length. Examine the following program:


; random bit
(= (bin) 0)
(= (bin) 1)
; binary list
(= (gen-bin $n)
   (if (> $n 0)
       (:: (bin) (gen-bin (- $n 1)))
       ()))
! (gen-bin 3)
Output
[(:: 1 (:: 0 (:: 1 ()))), (:: 1 (:: 0 (:: 0 ()))), (:: 1 (:: 1 (:: 1 ()))), (:: 1 (:: 1 (:: 0 ()))), (:: 0 (:: 0 (:: 1 ()))), (:: 0 (:: 0 (:: 0 ()))), (:: 0 (:: 1 (:: 1 ()))), (:: 0 (:: 1 (:: 0 ())))]
It will generate all the binary strings of length 3. Similarly, functions to generate all the binary trees of the given depth, or all the strings up to a certain length can be written.

Try to write a function, which will output the binary list of the same length as an input list. You don't need to calculate the length of this list and to use if.
(= (bin) 0)
(= (bin) 1)
(= (gen-bin-list ()) ())
(= (gen-bin-list ...)
   ...)

! (gen-bin-list (:: 1 (:: 5 (:: 7 ()))))
Output
[(gen-bin-list (:: 1 (:: 5 (:: 7 ()))))]

Solving problems with recursive nondeterminism
Let us put all the pieces together and solve the subset sum problem. In this problem, a list of integers is given, and one needs to find its elements whose sum will be equal to a given target sum. Candidate solutions in this problem can be represented as binary lists. Then, the sum of taken elements can be calculated as a sum of products of elements of two lists.


; random bit
(= (bin) 0)
(= (bin) 1)
; binary list with the same number of elements
(= (gen-bin-list ()) ())
(= (gen-bin-list (:: $x $xs))
   (:: (bin) (gen-bin-list $xs))
)
; sum of products of elements of two lists
(= (scalar-product () ()) 0)
(= (scalar-product (:: $x $xs) (:: $y $ys))
   (+ (* $x $y) (scalar-product $xs $ys))
)
; check the candidate solution
(= (test-solution $numbers $solution $target-sum)
   (if (== (scalar-product $numbers $solution)
           $target-sum)
       $solution
       (empty)
   )
)
; task
(= (task) (:: 8 (:: 3 (:: 10 (:: 17 ())))))
! (test-solution (task) (gen-bin-list (task)) 20)
Output
[(:: 0 (:: 1 (:: 0 (:: 1 ()))))]
This solution is not scalable, but it illustrates the general idea of how nondeterminism and recursion can be combined for problem solving. Note that passing a variable instead of (gen-bin-list (task)) will not work here. What is the difference with the frog example? The answer will be given in the next tutorial.


MeTTa from Ground Up: Patterns of Knowledge

Querying space content
Introduction
As a declarative language, MeTTa was designed for expressing complex relationships between entities of various types, performing computations on these relationships, and manipulating their structures. It allows programmers to specify AI algorithms and knowledge representations in a rich and flexible way. MeTTa code can be generated and processed in run-time by MeTTa programs themselves, which adds a lot of dynamism in working with complex data structures for AI tasks.

One of the main purposes of developing MeTTa was to operate over a knowledge metagraph called AtomSpace (or just Space), designed to store all sorts of knowledge, from raw sensory/motor data to linguistic and cultural knowledge, to abstract, mathematical, scientific or programming knowledge.

AtomSpace represents knowledge in the form of Atoms, the fundamental building block of all the data. Specifically, in the context of AI, an Atom can represent anything from objects, to concepts, to processes or relationships, to reasoning rules and algorithms.

While MeTTa may look like an ordinary language in certain aspects, it is built on top of operations over the knowledge metagraph, which is essential to understand how it works.

Knowledge declaration and matching query
Let us look at a basic example of specifying relations between concepts, e.g., family relationships. While there are different ways to do this, in MeTTa, one can simply put expressions like the following into the program


(Parent Tom Bob)
This expression being put into the program space can be treated as the fact that Tom is Bob's parent. We start Parent with capital P to distinguish it from a function, which we would prefer to start with p in this case, although this naming convention is not mandatory.

One can add more such expressions to the program space. But what can we do with such expressions? The tutorial overviewed the evaluation process of expressions, for which equalities are specified. But is there any use of expressions without equalities?

The core operation in MeTTa is matching. It searches for all declared atoms corresponding to the given pattern and produces the output pattern. The process is similar to the manner in which one can search text strings with regular expressions, but it is for searching for subgraphs in a metagraph.

We can compose a query for matching using the grounded function match. It expects three arguments:

a grounded atom referencing a Space;
pattern atom to be matched;
output pattern typically containing variables from the input pattern.
Basic examples
Let us consider the following program


(Parent Bob Ann)
; This match will be successful
! (match &self (Parent Bob Ann) (Bob is Ann`s father))
; The following line will return []
! (match &self (Parent Bob Joe) (Bob is Joe`s father))
Output
[(Bob is Ann`s father)]
[]
&self is a reference to the current program Space. We can refer to other Atomspaces, but we will cover it later. The second argument in the first match expression (Parent Bob Ann) is an expression to be matched against atoms in the current Space, and the third argument (Bob is Ann's father) is the atom to be returned if matching succeeded.

The program above will return [(Bob is Ann's father)] and [], since when the desired expression pattern wasn't found match returns nothing.

We can construct more interesting queries using variables. Let us consider the program


(Parent Tom Bob)
(Parent Pam Bob)
(Parent Tom Liz)
(Parent Bob Ann)

! (match &self (Parent $x Bob) $x) ; [Tom, Pam]
Output
[Tom, Pam]
The pattern (Parent $x Bob), i.e. "Who are Bob's parents?", can be matched against two atoms (facts) in the Space, and corresponding bindings for $x will be used to produce the result of match. Here, we will get two matches [Tom, Pam], which can be viewed as a nondeterministic evaluation of match.

Please, note that match doesn't search in subexpressions. The following code will return [Ann] only:


(Parent Bob Ann)
(Parent Pam (Parent Bob Pat))

! (match &self (Parent Bob $x) $x) ; Ann
Output
[Ann]
We can make even broader queries: "Who is a parent of whom?", or "Find $x and $y such that $x is a parent of $y".

(Parent Tom Bob)
(Parent Pam Bob)
(Parent Tom Liz)
(Parent Bob Ann)
(Parent Bob Pat)
(Parent Pat Pat)

! (match &self (Parent $x $y) ($x $y))

Output
[(Tom Bob), (Tom Liz), (Pam Bob), (Bob Ann), (Bob Pat), (Pat Pat)]
The output should contain the following pairs (the order can be different due to MeTTa's nondeterminism) [(Pat Bob), (Bob Ann), (Bob Pat), (Tom Bob), (Tom Liz), (Pat Pat)]. Can you add the query in the above program to retrieve only parents and children with same names?

Functions and unification
Function evaluation and matching
As discussed in the tutorial, evaluable expressions can contain variables, and they are pattern-matched against left-hand side of equalities. In fact, evaluation of expressions can be understood as recursively constructing queries for equalities. Consider this code as an example


(= (only-a A) (Input A is accepted))
! (only-a A)
! (only-a B)
! (only-a $x)
Output
[(Input A is accepted)]
[(only-a B)]
[(Input A is accepted)]
Evaluation of (only-a A) can be thought of as execution of query (match &self (= (only-a A) $result) $result). $result will be bound with the right-hand side of the function case (body), if the left-hand side matches with the expression under evaluation. Does it work for (only-a B) and (only-a $x)?

Let us check that the following program produces the same result:


(= (only-a A) (Input A is accepted))
! (match &self (= (only-a A) $result) $result)
! (match &self (= (only-a B) $result) $result)
! (match &self (= (only-a $x) $result) $result)
Output
[(Input A is accepted)]
[]
[(Input A is accepted)]
There is one difference. match produces the empty result in the second case, while the interpreter keeps this expression unreduced. The interpreter is performing some additional processing on top of such equality queries.

While allowing the MeTTa interpreter to construct equality queries automatically for evaluating expressions like (only-a A) is very convenient for functional programming, using match directly allows for more compact knowledge representation and efficient queries glued together in a custom way.

It should also be noted that obtaining multiple results in queries to knowledge bases is very typical, and since the semantics of evaluating expressions in MeTTa is natively related to such queries, all evaluations in MeTTa are secretly or explicitly nondeterministic.

Let us analyze the following program:


(Parent Tom Bob)
(Parent Pam Bob)
(Parent Tom Liz)
(Parent Bob Ann)
(= (get-parent-entries $x $y)
   (match &self (Parent $x $y) (Parent $x $y)))
(= (get-parents $x)
   (match &self (Parent $y $x) $y))
! (get-parent-entries Tom $_)
! (get-parents Bob)
Output
[(Parent Tom Liz), (Parent Tom Bob)]
[Pam, Tom]
We can call match from an ordinary function, and we can still pass variable arguments to it, so (get-parent-entries Tom $_) is equivalent to (match &self (Parent Tom $y) (Parent Tom $y)).
The result [(Parent Tom Liz), (Parent Tom Bob)] is not reduced further. It is convenient, when we want to represent pieces of knowledge and process them.
(get-parents Bob) returns [Tom, Pam]. Executing match from functions allows creating convenient functional abstractions while still working with declarative knowledge.
For example, how would you write a function, which returns grandparents of a given person?

(Parent Tom Bob)
(Parent Pam Bob)
(Parent Tom Liz)
(Parent Bob Ann)
(Parent Bob Pat)
(Parent Pat Jim)

(= (get-parents $x)
   (match &self (Parent $y $x) $y))
(= (get-grand-parents $x)
   (...))
! (get-grand-parents Pat)

Output
[(...)]
From facts to rules
One may notice that equality queries for functions suppose that there are free variables not only in the query, but also in the Atomspace entries. These entries can be not only function definitions, but other arbitrary expressions, which can be used to represent general knowledge or rules. For example, one can write


(Parent Tom Bob)
(Parent Bob Ann)
(Implies (Parent $x $y) (Child $y $x))
(= (deduce $B)
   (match &self (Implies $A $B)
          (match &self $A $B))
)
(= (conclude $A)
   (match &self (Implies $A $B)
          (match &self $A $B))
)
! (deduce (Child $x Tom))    ; [(Child Bob Tom)]
! (conclude (Parent Bob $y)) ; [(Child Ann Bob)]
Output
[(Child Bob Tom)]
[(Child Ann Bob)]
If Child and Parent were predicates returning True or False (as in the frog example), we could somehow use = instead of Implies. But here we don't evaluate the premise to True or False, but check that it is in the knowledge base. It makes inference better controllable. We can easily go from premises to conclusions with conclude, or to verify conclusions by searching for suitable premises with deduce.

We will discuss different ways of introducing reasoning in MeTTa in more detail later. What we want to focus on now is that in both cases a query with variables is constructed, say, (Implies (Parent Bob $y) $B) and it should be matched against some entry in the knowledge base with variables as well, namely, (Implies (Parent $x $y) (Child $y $x)) in our example. This operation is called unification, and it is available in MeTTa in addition to match.

Unification
Function unify accepts two patterns to be unified (matched together in such the way that shared variables in them get most general non-contradictory substitutions). The function is evaluated to its third argument if unification is successful and to the fourth argument otherwise. The following program shows the basic example.


! (unify (parent $x Bob) ; the first pattern
         (parent Tom $y) ; the second pattern
         ($x $y) ; the output for successful unification
         Fail) ; fallback
Output
[(Tom Bob)]
Here, we unify two expressions (parent $x Bob) and (parent Tom $y), and return a tuple ($x $y) if unification succeeded. The Fail atom will be returned if there are no matches. Note that (unify (A $x) ($x B) Yes No) will be reduced to No, because $x should have the same binding in both patterns (and it cannot be A and B simultaneously).

One of the first two arguments can be a reference to a Space as well. In this case, it will work like match but with an alternative option in the case of failed matching:


(Parent Tom Bob)
(Parent Bob Ann)
! (unify &self (Parent $x Bob) $x Fail) ; [Tom]
Output
[Tom]
Here, we pass a reference to the current Space as the first argument, so the second expression (parent $x Bob) is matched against the whole set of declared knowledge.

Chained unification
Let us analyze how (conclude (Parent Bob $y)) from the above example is evaluated.

At first, (match &self (= (Parent Bob $y) $result) $result) is executed to evaluate the subexpression. But this query returns no result, because equalities for Parent are not defined. Thus, (Parent Bob $y) remains unreduced.
Thus, the equality query for the whole expression (match &self (= (conclude (Parent Bob $y)) $result) $result) is executed. The following two expressions (one is the query and another one is from Space) are unifiable:

(= (conclude (Parent Bob $y))
   $result)
(= (conclude       $A)
   (match &self (Implies $A $B)
          (match &self $A $B)))
$A will be bound to (Parent Bob $y), and $result will be


(match &self (Implies (Parent Bob $y) $B)
             (match &self (Parent Bob $y) $B))
match is executed directly as a grounded function (otherwise another equality query would be constructed) with (Implies (Parent Bob $y) $B) as a query. It unifies with the following entry in the Space:

(Implies (Parent Bob $y)      $B      )
(Implies (Parent $x  $y) (Child $y $x))
One may notice that there could be some collisions of variable names, and the interpreter should deal with this. In overall, $x gets bound to Bob, and $B gets bound to (Child $y Bob). Since the output of this match is (match &self (Parent Bob $y) $B), the expression for further evaluation becomes (match &self (Parent Bob $y) (Child $y Bob)).

(Parent Bob $y) unifies with (Parent Bob Ann) yielding (Child Ann Bob)
Query (= (Child Ann Bob) $result) finds no matches, so (Child Ann Bob) is the final result.
The overall chain of transformations in the course of interpretation can be viewed as:


1. (conclude (Parent Bob $y))
2. (match &self (Implies (Parent Bob $y) $B)
          (match &self (Parent Bob $y) $B))
3. (match &self (Parent Bob $y) (Child $y Bob))
4. (Child Ann Bob)
These are not all the steps done by the interpreter, but they give the overall picture of what is really going on under the hood.

Nested queries and recursive graph traversal
Composite queries
We've already seen queries for conclude and deduce, which result is another query. At the same time, chaining of queries can be done in a more functional style with equalities as it could be done for


(= (get-grand-parents $x)
   ((get-parents (get-parents $x))))
Keeping knowledge declarative can be useful for implementing reasoning over it.

Imagine that we add more info on people like (Female Pam) or (Male Tom) into the knowledge base, and want to define more relations such as sister. One can turn facts into equalities like (= (Female Pam) True) and use functional logic (as in the frog example), but let us keep simple facts for now.

One can add more functions like get-parents. A function for female would be more convenient to represent as a filter, e.g. (= (female $x) (match &self (Female $x) $x)), so it will be composable, e.g. (= (get-mother $x $y) (female (get-parents $x $y))).

One can do this by a composite query instead.

(Female Pam)
(Male Tom)
(Male Bob)
(Female Liz)
(Female Pat)
(Female Ann)
(Male Jim)
(Parent Tom Bob)
(Parent Pam Bob)
(Parent Tom Liz)
(Parent Bob Ann)
(Parent Bob Pat)
(Parent Pat Jim)

(= (get-sister $x)
   (match &self
     (, (Parent $y $x)
        (Parent $y $z)
        (Female $z))
     $z
   )
)
! (get-sister Bob)

Output
[Liz]
Composite queries contain a few patterns (united by , into one expression), which should be satisfied simultaneously. Such queries can be efficient if the Atomspace query engine efficiently processes joints. This can be important for large knowledge bases. Otherwise, it is necessary to be careful about the order of nested queries of filters. For example, having (Female $z) with free variable $z as the innermost functional call or (match &self (Female $z) ...) as the outermost query in a nested sequence of queries will be highly inefficient, because it will first extract all the females from the knowledge base, and only then will narrow down the set of the results.

Notice that the above program is imprecise. How can the mistake be fixed (check the sister of Liz - one option would be to introduce (different $x $y) as a filter)? You can try implementing other relations like uncle in the above program or rewrite it in a functional way. Typically, we would like to represent such concepts using other derived concepts rather than monolithic composite queries (e.g. "Uncle is a brother of a parent" rather than "Uncle is a male child of a parent of a parent, but not the parent").

Recursion for graph traversal
Let us define the predecessor relation:

 For any `$x` and `$z`: `$x` is a predecessor of `$z`  
    if there is `$y` such that  
       `$y` is a parent of `$z` and  
       `$x` is a predecessor of `$y`  
Recursion is a convenient way to represent such relations.


(Parent Tom Bob)
(Parent Pam Bob)
(Parent Tom Liz)
(Parent Bob Ann)
(Parent Bob Pat)
(Parent Pat Jim)
(Parent Jim Lil)

(= (parent $x $y) (match &self (Parent $x $y) $x))
(= (predecessor $x $z) (parent $x $z))
(= (predecessor $x $z) (predecessor $x (parent $y $z)))
; Who are predecessors of Lil
! (predecessor $x Lil)
Output
[Jim, Bob, Pam, Tom, Pat]

Basics of Types and Metatypes

Concrete types
Types of symbols
Atoms in MeTTa are typed. Types of atoms are also represented as atoms (typically, symbolic atoms and expressions). Expressions of the form (: <atom> <type>) are used to assign types. For example, to designate that the symbol atom a has a custom type A one needs to add the expression (: a A) to the space (program).

Note that since A here is a symbol atom, it can also have a type, e.g., (: A Type). The symbol atom Type is conventionally used in MeTTa to denote the type of type atoms. However, it is not assigned automatically. That is, declaration (: a A) doesn't force A to be of type Type.

When an atom has no assigned type, it has %Undefined% type. The value of %Undefined% type can be type-checked with any type required.

One can check the type of an atom with get-type function from stdlib.


(: a A)
(: b B)
(: A Type)

! (get-type a) ; A
! (get-type b) ; B
! (get-type c) ; %Undefined%
! (get-type A) ; Type
! (get-type B) ; %Undefined%
Output
[A]
[B]
[%Undefined%]
[Type]
[%Undefined%]
Here, we declared types A and B for a and b correspondingly, and type Type for A. get-type returns the declared types or %Undefined% if no type information is provided for the symbol.

Types of expressions
Consider the following program.


(: a A)
(: b B)
! (get-type (a b)) ; (A B)
Output
[(A B)]
The type of expression (a b) will be (A B). The type of a tuple is a tuple of types of its elements. However, what if we want to apply a function to an argument? Usually, we want to check if the function argument is of appropriate type. Also, while function applications themselves are expressions, they are transformed in the course of evaluation, and the result has its own type. Basically, we want to be able to transform (or reduce) types of expressions before or without transforming expressions themselves.

Arrow -> is a built-in symbol of the type system in MeTTa, which is used to create a function type, for example (: foo (-> A B)). This type signature says that foo can accept an argument of type A and its result will be of type B:


(: a A)
(: foo (-> A B))
! (get-type (foo a)) ; B
Output
[B]
Let us note that

We didn't provide a body for foo, so (foo a) is not reduced at all, and its type B is derived purely from the types of foo and a. It doesn't matter whether foo is a real function or a data constructor.
Equality queries themselves don't care about the position of the function symbol in the tuple, and the following code is perfectly correct

(= ($1 infix-f $2) ($2 $1))
! (match &self (= (1 infix-f 2) $r) $r)
Output
[(2 1)]
However, reduction of the type of a tuple is performed if its first element has an arrow (function) type. For convenience and by convention, the first element in a tuple is treated specially for function application.

Type-checking
Types can protect against incorrectly constructed expressions including misuse of a function, when we want it to accept arguments of a certain type.


; This function accepts an atom of type A and returns an atom of type B
(: foo (-> A B))
(: a A)
(: b B)

! (foo a) ; no error
! (get-type (foo b)) ; no result
! (b foo) ; notice: no error
! (get-type (b foo)) ; (B (-> A B))
! (foo b) ; type error
Output
[(foo a)]
[]
[(b foo)]
[(B (-> A B))]
[(Error b BadType)]
We didn't define an equality for foo, so (foo a) reduces to itself. However, an attempt to evaluate (foo b) results in the error expression. When we try to get the type of this expression with (get-type (foo b)), the result is empty meaning that this expression has no valid type.

Notice that evaluation of (b foo) doesn't produce an error. The arrow type of foo in the second position of the tuple doesn't cause transformation of its type. Indeed, (get-type (b foo)) produces (B (-> A B)).

Gradual typing
Let us consider what types will expressions have, when some of their elements are %Undefined%. Run the following program to check the currently implemented behavior


(: foo (-> A B))
(: a A)
! (get-type (foo c))
! (get-type (g a))
Output
[B]
[%Undefined%]
Note that g and c are of %Undefined% type, while foo and a are typed. The result can be different depending on which type is not defined, of the function or its argument.

Multiple arguments
Functions can have more than one argument. In their type signature, types of their parameters are listed first, and the return type is put at the end much like for functions with one argument.

The wrong order of arguments with different types as well as the wrong number of arguments will render the type of the whole expression to be empty (invalid).

; This function takes two atoms of type A and B and returns an atom of type C
(: foo2 (-> A B C))
(: a A)
(: b B)

! (get-type (foo2 a b)) ; C
! (get-type (foo2 b a)) ; empty
! (get-type (foo2 a)) ; empty
! (foo2 a c) ; no error
! (foo2 b a) ; type error (the interpreter stops on error)
! (foo2 c) ; would also be type error

Output
[C]
[]
[]
[(foo2 a c)]
[(Error b BadType)]
Here, the atom c is of %Undefined% type and it can be matched against an atom of any other type. Thus, (foo2 a c) will not produce an error. However, (foo2 c) will not work because of wrong arity.

Also notice that it is not necessary to define an instance of type C. foo2 by itself acts as a constructor for this type.

What will be the type of a function with zero arguments? Its type expression will have only the return type after ->, e.g.


(: a A)
(: const-a (-> A))
(= (const-a) a)
Nested expressions
Types of nested expressions are inferred from innermost expressions outside. You can try nesting typed expressions in the sandbox below and see what goes wrong.

(: foo (-> A B))
(: bar (-> B B A))
(: a A)
! (get-type (bar (foo a) (foo a)))
! (get-type (foo (bar (foo a) (foo a))))


Output
[A]
[B]
Note that type signatures can be nested expressions by themselves:


(: foo-pair (-> (A B) C))
(: a A)
(: b B)

! (get-type (foo-pair a b)) ; empty
! (get-type (foo-pair (a b))) ; C
Output
[]
[C]
As was mentioned above, an arrow type of the atom, which is not the first in the tuple, will not cause type reduction. Thus, one may apply a function to another function (or a data constructor):


(: foo (-> (-> A B) C))
(: bar (-> A B))
(: a A)

! (get-type (foo bar)) ; C
! (get-type (foo (bar a))) ; empty
Output
[C]
[]
Here, the type of bar matches the type of the first parameter of foo. Thus, (foo bar) is a well-typed expression, which overall type corresponds to the return type of foo, namely, C.

(foo (bar a)), in turn, is badly typed, because the type of (bar a) is reduced to B, which does not correspond to (-> A B) expected by foo.

Similarly, the return type of a function can be an arbitrary expression including arrow types. Try to construct a well-typed expression involving all the following symbols

(: foo (-> C (-> A B)))
(: bar (-> B A))
(: a A)
(: c C)

! (get-type (...))

Output
[%Undefined%]
We intentionally don't provide function bodies here to underline that typing imposes purely structural restrictions on expressions, which don't require understanding the semantics of functions. In the example above, foo accepts an atom of type C. Thus, (foo c) is well-typed, and its reduced type is (-> A B). This is an arrow type meaning that we can put this expression at the first position of a tuple (function application), and it will expect an atom of type A. Thus, ((foo c) a) should be well-typed, and its reduced type will be B. Thus, we can apply bar to it. Will (bar ((foo c) a)) be indeed well-typed?

Grounded atoms
Grounded atoms are also typed. One can check their types with get-type as well:


! (get-type 1) ; Number
! (get-type 1.1) ; Number
! (get-type +) ; (-> Number Number Number)
! (get-type (+ 1 2.1)) ; Number
Output
[Number]
[Number]
[(-> Number Number Number)]
[Number]
As the example shows, 1 and 1.1 both are of Number type, although their data-level representation can be different. + accepts two arguments of Number type and returns the result of the same type. Thus, Number is repeated three times in its type signature.

Let us note once again that the argument of get-type is not evaluated, and get-type returns an inferred type of expression. In particular, when we try to apply + to the argument of a wrong type, the result is the error expression (which by itself is well-typed), but get-type returns the empty result instead of returning the type of the error message:


(: a A)
! (get-type (+ 1 a)) ; empty
! (get-type (+ 1 b)) ; Number
! (+ 1 b) ; no error, not reduced
! (+ 1 a) ; type error
Output
[]
[Number]
[(+ 1 b)]
[(Error a BadType)]
In this program, we also tried to see the type of application of the grounded function to the argument of %Undefined% type. Such the expression type-checks. However, it is not reduced in the course of evaluation. Thus, grounded functions work as partial functions or expression constructors in such cases. MeTTa is a symbolic language, and the possibility to construct expressions for further analysis is one of its main features. Ultimately, grounded functions should not differ from symbolically defined functions in this regard.

Recursive and parametric types
Recursive data types
All types allow constructing recursive expressions, when there is at least one function accepting and returning values of this type. This is true for arithmetic expressions or compositions of operations over strings. Say, any expression like (+ (- 3 1) (* 2 (+ 3 4))) will be of Number type. We expect that the result of evaluation of such expressions will have the same type as the reduced type of the expression itself.

However, in some cases, we don't even want such expressions to be reduced, but want to consider them as instances of the reduced type. Consider the simple example of Peano numbers:


(: Z Nat) ; Z is "zero"
(: S (-> Nat Nat)) ; S "constructs" the next number
! (S Z) ; this is "one"
! (S (S Z)) ; this is "two"
! (get-type (S (S (S Z)))) ; Nat
! (get-type (S S)) ; not Nat
Output
[(S Z)]
[(S (S Z))]
[Nat]
[]
We didn't define the type of Nat itself. One may prefer to add (: Nat Type) for clarity.

In the code above, S does nothing. It could be a grounded function, which adds 1 to the given number in some binary representation. Instead, (S some-nat) is not reduced and serves itself to represent the next natural number. It doesn't actually important that S is not a function, and (S some-nat) is not calculated. In fact, it could be. What really matters is that instances of Nat can be deconstructed and pattern-matched.

The following code shows, how Nat as a recursive data type is processed by pattern matching.


(: Z Nat)
(: S (-> Nat Nat))
(: Greater (-> Nat Nat Bool))
(= (Greater (S $x) Z)
   True)
(= (Greater Z $x)
   False)
(= (Greater (S $x) (S $y))
   (Greater $x $y))
! (Greater (S Z) (S Z)) ; False
! (Greater (S (S Z)) (S Z)) ; True
Output
[False]
[True]
While this implementation is inefficient for computations, it is more suitable for reasoning.

More practical use of recursive data structures is in the form of containers to store data. We already constructed them in the previous tutorials, but without types. Let us add typing information and define the type of list of numbers:


(: NilNum ListNum)
(: ConsNum (-> Number ListNum ListNum))
! (get-type (ConsNum 1 (ConsNum 2 (ConsNum 3 NilNum)))) ; ListNum
! (ConsNum 1 (ConsNum "S" NilNum)) ; BadType
Output
[ListNum]
[(Error (ConsNum "S" NilNum) BadType)]
The type reduction for such expressions is rather straightforward: the type of (ConsNum 3 NilNum) is reduced to ListNum, since ConsNum is of (-> Number ListNum ListNum) type and its arguments are of Number and ListNum types. Consequently, (ConsNum 2 (...)) is reduced to ListNum again for the same reason, and so on. For the second case, (ConsNum "S" NilNum) is badly typed.

Such expressions can be recursively processed as was done in the tutorial. Adding type information makes the purpose of the corresponding functions clearer and allows detecting mistakes.

Parametric types
Type expressions can contain variables. Type-checking for such types is implemented and can be understood via pattern-matching. Let us consider some basic examples.

Stdlib contains a comparison operator ==. The following code


! (get-type ==)
! (== 1 "S")
Output
[(-> $t#86704 $t#86704 Bool)]
[(Error "S" BadType)]
will reveal that (== 1 +) is badly typed, and the reason is that == has the type (-> $t $t Bool). This means that the arguments can be of an arbitrary but same type. Type-checking and reduction can be understood here as an attempt to unify (-> $t $t Bool) with (-> Number String $result).

It deserves noting that the output type can also be variable, e.g.


(: apply (-> (-> $tx $ty) $tx $ty))
(= (apply $f $x) ($f $x))
! (apply not False) ; True
! (get-type (apply not False)) ; Bool
! (unify (-> (-> $tx  $ty)  $tx  $ty)
         (-> (-> Bool Bool) Bool $result)
         $result
         BadType) ; Bool
! (apply not 1) ; BadType
Output
[True]
[Bool]
[Bool]
[(Error 1 BadType)]
not has (-> Bool Bool) type and False is of Bool type. Thus, arguments of (apply not False) suppose that the function type signature should be unified with (-> (-> Bool Bool) Bool $result). This results in binding both $tx and $ty to Bool, and the output type ($ty) also becomes Bool.

In the tutorial, we defined apply-twice, which takes the function as an argument and applies it two time to the second argument. But what if the output type of the function is different from its input type? Can it be applied to the result of its own application? Try to specify the type of apply-twice to catch the error in the last expression:
(: apply-twice (-> ? ? ?))
(= (apply-twice $f $x)
   ($f ($f $x)))
(: greater-than-0 (-> Number Bool))
(= (greater-than-0 $x) (> $x 0))
! (get-type (apply-twice not True)) ; should be [Bool]
! (get-type (apply-twice greater-than-0 1)) ; should be []

Output
[]
[]
Besides defining higher-order functions, parametric types are useful for recursive data structures. One of the most common examples is List. How can we define it as a container of elements of an arbitrary but same type? We can parameterize the type List itself with the type of its elements:


(: Nil (List $t))
(: Cons (-> $t (List $t) (List $t)))
! (get-type (Cons 1 (Cons 2 Nil)))
! (get-type (Cons False (Cons True Nil)))
! (get-type (Cons + (Cons - Nil)))
! (get-type (Cons True (Cons 1 Nil)))
Output
[(List Number)]
[(List Bool)]
[(List (-> Number Number Number))]
[]
Let us consider how the type of (Cons 2 Nil) is derived. These arguments of Cons suppose its type signature to be undergo the following unification:


! (unify (-> $t     (List $t) (List $t))
         (-> Number (List $t) $result)
         $result
         BadType)
Output
[(List Number)]
$t gets bound to Number, and the output type (List $t) becomes (List Number).

Then, the outer Cons in (Cons 1 (Cons 2 Nil)) receives the arguments of types Number and (List Number), which can be simultaneously unified with $t and (List $t) producing (List Number) as the output type once again.

In contrast, the outer Cons in (Cons True (Cons 1 Nil)) receives Bool and (List Number). Apparently, $t in (-> $t (List $t) (List $t)) cannot be bound to both Bool and Number resulting in type error.

Functions can receive arguments of parametric types, and type-checking will help to catch possible mistakes. Consider the following example

(: Nil (List $t))
(: Cons (-> $t (List $t) (List $t)))
(: first (-> (List $t) $t))
(: append (-> (List $t) (List $t) (List $t)))
! (get-type
    (+ 1
      (first (append (Cons 1 Nil)
                     (Cons 2 Nil)))))

Output
[Number]
We don't need function bodies for type-checking. first returns the first element of (List $t)-typed list, and this element should be of $t type. append concatenates two lists with elements of the same type and produces the list of elements of this type as well. When we start considering a specific expression and unify types of its elements with type signatures of corresponding functions, variables in types get bindings. Apparently, types of (Cons 1 Nil) and (Cons 2 Nil) are reduced to (List Number). Then, (append (...) (...)) gets the same type, while the type of (first (...)) is reduced to Number. You can experiment with making the expression badly typed in the code above and see, at which point the error is detected.

Functional programming with types is discussed in more detail in this tutorial. However, types in MeTTa are more general than generalized algebraic data types and are similar to dependent types. The use of such advanced types is elaborated in this tutorial, in particular, in application to knowledge representation and reasoning.

Metatypes
Peeking into metatypes
In MeTTa, we may need to analyze the structure of atoms themselves. The tutorial starts with introducing four kinds of atoms - Symbol, Expression, Variable, Grounded. We refer to them as metatypes. One can use get-metatype to retrieve the metatype of an atom


! (get-metatype 1) ; Grounded
! (get-metatype +) ; Grounded
! (get-metatype (+ 1 2)) ; Expression
! (get-metatype a) ; Symbol
! (get-metatype (a b)) ; Expression
! (get-metatype $x) ; Variable
Output
[Grounded]
[Grounded]
[Expression]
[Symbol]
[Expression]
[Variable]
How to process atoms depending on their metatypes is discussed in another tutorial. In this tutorial, we discuss one particular metatype, which is widely utilized in MeTTa to control the order of evaluation. You should have noticed that arguments of some functions are not reduced before the function is called. This is true for get-type and get-metatype functions. Let us check their type signatures:


! (get-type get-type) ; (-> Atom Atom)
! (get-type get-metatype) ; (-> Atom Atom)
Output
[(-> Atom %Undefined%)]
[(-> Atom Atom)]
Here, Atom is a supertype for Symbol, Expression, Variable, Grounded. While metatypes can appear in ordinary type signatures, they should not be assigned explicitly, e.g. (: a Expression), except for the following special case.

Atom is treated specially by the interpreter - if a function expects an argument of Atom type, this argument is not reduced before passing to the function. This is why, say, (get-metatype (+ 1 2)) returns Expression. It is worth noting that Atom as a return result will have no special effect. While Atom as the return type could prevent the result from further evaluation, this feature is not implemented in the current version of MeTTa.

Using arguments of Atom type is essential for meta-programming and self-reflection in MeTTa. However, it has a lot of other more common uses.

Quoting MeTTa code
We encountered error expressions. These expressions can contain unreduced atoms, because Error expects the arguments of Atom type:


! (get-type Error) ; (-> Atom Atom ErrorType)
! (get-metatype Error) ; just Symbol
! (get-type (Error Foo Boo)) ; ErrorType
! (Error (+ 1 2) (+ 1 +)) ; arguments are not evaluated
Output
[(-> Atom Atom ErrorType)]
[Symbol]
[ErrorType]
[(Error (+ 1 2) (+ 1 +))]
Error is not a grounded atom, it is just a symbol. It doesn't even have defined equalities, so it works just an expression constructor, which prevents its arguments from being evaluated and which has a return type, which can be used to catch errors.

Another very simple constructor from stdlib is quote, which is defined just as (: quote (-> Atom Atom)). It does nothing except of wrapping its argument and preventing it from being evaluated.


! (get-type quote)
! (quote (+ 1 2))
! (get-type if)
Output
[(-> Atom Atom)]
[(quote (+ 1 2))]
[(-> Bool Atom Atom $t#3850)]
Some programming languages introduce quote as a special symbol known by the interpreter (otherwise its argument would be evaluated). Consequently, any term should be quoted, when we want to avoid evaluating it. However, quote is an ordinary symbol in MeTTa. What is specially treated is the Atom metatype for arguments. It appears to be convenient not only for extensive work with MeTTa programs in MeTTa itself (for code generation and analysis, automatic programming, meta-programming, genetic programming and such), but also for implementing traditional control statements.

if under the hood
As was mentioned in the tutorial, the if statement in MeTTa works much like if-then-else construction in any other language. if is not an ordinary function and typically requires a special treatment in interpreters or compilers to avoid evaluation of branches not triggered by the condition.

However, its implementation in MeTTa can be done with the following equalities


(= (if True $then $else) $then)
(= (if False $then $else) $else)
The trick is to have the type signature with the first argument typed Bool, and the next two arguments typed Atom. The first argument typed Bool can be an expression to evaluate like (> a 0), or a True/False value. The Atom-types arguments $then and $else will not be evaluated while passing into the if function. However, once the if-expression has been reduced to either of them, the interpreter will chain its evaluation to obtain the final result.

Consider the following example
(: my-if (-> Bool Atom Atom Atom))
(= (my-if True $then $else) $then)
(= (my-if False $then $else) $else)
(= (loop) (loop))
(= (OK) OK!)
! (my-if (> 0 1) (loop) (OK))

Output
[(OK)]
If you comment out the type definition, then the program will go into an infinite loop trying to evaluate all the arguments of my-if. Lazy model of computation could automatically postpone evaluation of $then and $else expressions until they are not required, but it is not currently implemented.

Can you imagine how a "sequential and" function can be written, which evaluates its second argument, only if the first argument is True?

(: seq-and (-> ... ... Bool))
(= (seq-and ... ...) ...)
(= (seq-and ... ...) ...)
(: loop (-> Bool Bool))
! (seq-and False (loop)) ; should be False
! (seq-and True True) ; should be True

Output
[(Error False BadType)]
Apparently, in the proposed setting, the first argument should be evaluated, so its type should be Bool, while the second argument shouldn't be immediately evaluated. What will be the whole solution?

Transforming expressions
One may want to use Atom-typed arguments not only for just avoiding computations or quoting expressions, but to modify them before evaluation.

Let us consider a very simple example with swapping the arguments of a function. The code below will give -7 as a result


(: swap-arguments-atom (-> Atom Atom))
(= (swap-arguments-atom ($op $arg1 $arg2))
   ($op $arg2 $arg1)
)
! (swap-arguments-atom (- 15 8))
Output
<empty string>
At the same time, the same code without typing will not work properly and will return [(swap-arguments 7)], because (- 15 8) will be reduced by the interpreter before passing to the swap-arguments and will not be pattern-matched against ($op $arg1 $arg2)


(= (swap-arguments ($op $arg1 $arg2))
   ($op $arg2 $arg1)
)
! (swap-arguments (- 15 8))
Output
[(swap-arguments 7)]
One more example of using the Atom type is comparing expressions


; `atom-eq` returns True, when arguments are identical
; (can be unified with the same variable)
(: atom-eq (-> Atom Atom Bool))
(= (atom-eq $x $x) True)

; These expressions are identical:
! (atom-eq (+ 1 2) (+ 1 2))

; the following will not be reduced because the expressions are not the same 
; (even though the result of their evaluation would be)
! (atom-eq 3 (+ 1 2))
Output
[True]
[(atom-eq 3 (+ 1 2))]

Controlling pattern matching
Both standard and custom functions in MeTTa can have Atom-typed arguments, which will not be reduced before these functions are evaluated. But we may want to call them on a result of another function call. What is the best way to do this? Before answering this question, let us consider match in more detail.

Type signature of the match function
Pattern matching is the core operation in MeTTa, and it is implemented using the match function, which locates all atoms in the given Space that match the provided pattern and generates the output pattern.

Let us recall that the match function has three arguments:

a grounded atom referencing a Space;
a pattern to be matched against atoms in the Space (query);
an output pattern typically containing variables from the input pattern.
Consider the type of match:


! (get-type match)
Output
[(-> SpaceType Atom Atom %Undefined%)]
The second and the third arguments are of Atom type. Thus, the input and the output pattern are passed to match as is, without reduction. Preventing reduction of the input pattern is essentially needed for the possibility to use any pattern for matching. The output pattern is instantiated by match and returned, and only then it is evaluated further by the interpreter.

in-and-out behavior of match
In the following example, (Green $who) is evaluated to True for $who bound to Tod due to the corresponding equality.


(Green Sam)
(= (Green Tod) True)
! ($who (Green $who)) ; (Tod True)
! (match &self (Green $who) $who) ; Sam
Output
[(Tod True)]
[Sam]
However, (Green $who) is not reduced when passed to match, and the query returns Sam, without utilizing the equality because (Green Sam) is added to the Space.

Let us verify that the result of match will be evaluated further. In the following example, match first finds two entries satisfying the pattern (Green $who) and instantiates the output pattern on the base of each of them, but only (Frog Sam) is evaluated to True on the base of one available equality, while (Frog Tod) remains unreduced.


(Green Sam)
(Green Tod)
(= (Frog Sam) True)
! (match &self (Green $who) (Frog $who)) ; [True, (Frog Tod)]
Output
[True, (Frog Tod)]
We can verify that instantiation of the output pattern happens before its evaluation:


(Green Sam)
(= (Frog Sam) True)
! (match &self (Green $who) (quote (Frog $who)))
Output
[(quote (Frog Sam))]
Here, (Green $who) is matched against (Green Sam), $who gets bound to Sam, and then it is substituted to the output pattern yielding (quote (Frog Sam)), in which (Frog Sam) is not reduced further to True, because quote also expects Atom. Thus, match can be thought of as transformation of the input pattern to the output pattern. It performs no additional evaluation of patterns by itself.

Returning output patterns with substituted variables before further evaluation is very convenient for nested queries. Consider the following example:


(Green Sam)
(Likes Sam Emi)
(Likes Tod Kat)
! (match &self (Green $who)
    (match &self (Likes $who $x) $x))
! (match &self (Green $who)
    (match &self (Likes $boo $x) $x))
! (match &self (Likes $who $x)
    (match &self (Green $x) $x))
! (match &self (Likes $who $x)
    (match &self (Green $boo) $boo))
Output
[Emi]
[Kat, Emi]
[]
[Sam, Sam]
The output of the outer query is another query. The inner query is not evaluated by itself, but instantiated as the output of the outer query.

In the first case, $who gets bound to Sam and the pattern in the second query becomes (Frog Sam $x), which has only one match, so the output is Emi.
In the second case, $who is not used in the inner query, and there are two results, because the pattern of the second query remains (Likes $boo $x).
In the third case, there are no results, because the outer query produces two results, but neither (Green Emi) nor (Green Kat) are in the Space.
In the last case, Sam is returned two times. The outer query returns two results, and although its variables are not used in the inner query, it is evaluated twice.
Patterns are not type-checked
Functions with Atom-typed parameters can accept atoms of any other type, including badly typed expressions, which are not supposed to be reduced. As it was mentioned earlier, this behavior can be useful in different situations. Indeed, why couldn't we, say, quote a badly typed expression as an incorrect example?

It should be noted, though, that providing specific types for function parameters and simultaneously indicating that the corresponding arguments should not be reduced could be useful in other cases. Unfortunately, it is currently not possible to provide a specific type and a metatype simultaneously (which is one of the known issues).

At the same time, match is a very basic function, which should not be restricted in its ability to both accept and return "incorrect" expressions. Thus, one should keep in mind that match does not perform type-checking on its arguments, which is intentional and expected.

The following program contains a badly typed expression, which can still be pattern-matched (and match can accept a badly typed pattern):


(+ 1 False)
! (match &self (+ 1 False) OK) ; OK
! (match &self (+ 1 $x) $x) ; False
Output
[OK]
[False]
It can be useful to deal with "wrong" MeTTa programs on a meta-level in MeTTa itself, so this behavior of match allows us to write code that analyzes badly typed expressions within MeTTa.

Type of =
MeTTa programs typically contain many equalities. But is there a guarantee that the function will indeed return the declared type? This is achieved by requiring that both parts of equalities are of the same type. Consider the following code:


(: foo (-> Number Bool))
(= (foo $x) (+ $x 1))
! (get-type (foo $x)) ; Bool
! (get-type (+ $x 1)) ; Number
! (get-type =) ; (-> $t#nnnn $t#nnnn Atom)
! (= (foo $x) (+ $x 1)) ; BadType
Output
[Bool]
[Number]
[(-> $t#3150 $t#3150 %Undefined%)]
[(Error (+ $x 1) BadType)]
We declared the type of foo to be (-> Number Bool). On the base of this definition, the type of (foo $x) can be reduced to Bool, which is the expected type of its result. However, the type of its body (+ $x 1) is reduced to Number. If we get the type of =, we will see that both its arguments should be of the same type. The result type of = is Atom, since it is not a function (unless someone adds an equality over equalities, which is permissible). If one tries to "execute" this equality, it will indeed return the type error.

Programs can contain badly typed expressions as we discussed earlier. However, this may permit badly defined functions. ! (pragma! type-check auto) can be used to enable automatic detection of such errors:


! (pragma! type-check auto) ; ()
(: foo (-> Number Bool))
(= (foo $x) (+ $x 1)) ; BadType
Output
[()]
[(Error (= (foo $x) (+ $x 1)) BadType)]
This pragma option turns on type-checking of expressions before adding them to the Space (without evaluation of the expression itself).

let's evaluate
Sometimes we need to evaluate an expression before passing it to a function, which expects Atom-typed arguments. What is the best way to do this?

One trick could be to write a wrapper function like this


(= (call-by-value $f $arg)
   ($f $arg))
! (call-by-value quote (+ 1 2)) ; (quote 3)
Output
[(quote 3)]
Arguments of this function are not declared to be of Atom type, so they are evaluated before the function is called. Then, the function simply passes its evaluated argument to the given function. However, it is not needed to write such a wrapper function, because there is a more convenient way with the use of operation let from stdlib.

let takes three arguments:

a variable atom (or, more generally, a pattern)
an expression to be evaluated and bound to the variable (or, more generally, matched against the pattern in the first argument)
the output expression (which typically contains a variable to be substituted)

! (let $x (+ 1 2) (quote $x)) ; (quote 3)
(: Z Nat)
! (get-metatype (get-type Z)) ; (get-type Z) is Expression
! (let $x (get-type Z) (get-metatype $x)) ; Nat is Symbol
Output
[(quote 3)]
[Expression]
[Symbol]
One may also want to evaluate some subexpression before constructing an expression for pattern-matching


(= (age Bob) 5)
(= (age Sam) 8)
(= (age Ann) 3)
(= (age Tom) 5)
(= (of-same-age $who)
   (let $age (age $who)
        (match &self (= (age $other) $age)
               $other)))
! (of-same-age Bob) ; [Bob, Tom]
; without `of-same-age`:
! (let $age (age Bob)
       (match &self (= (age $other) $age)
              $other)) ; also [Bob, Tom]
! (match &self (= (age $other) (age Bob))
         $other) ; does not pattern-match
; evaluating the whole pattern is a bad idea
! (let $pattern (= (age $other) (age Bob))
       $pattern) ; [(= 5 5), (= 8 5), (= 5 5), (= 3 5)]
! (let $pattern (= (age $other) (age Bob))
       (match &self $pattern $other)) ; does not pattern-match
Output
[Tom, Bob]
[Bob, Tom]
[]
[(= 5 5), (= 8 5), (= 3 5), (= 5 5)]
[]
It can be seen that let helps to evaluate (age Bob) before constructing a pattern for retrieval. However, evaluating the whole pattern is typically a bad idea. That is why patterns in match are of Atom type, and let is used when something should be evaluated beforehand.

As was remarked before, let can accept a pattern instead of a single variable. More detailed information on let together with other functions from stdlib are provided in the next tutorial.

Unit type
Unit is a type that has exactly one possible value unit serving as a return value for functions, which return "nothing". However, from the type-theoretic point of view, mappings to the empty set do not exist (they are non-constructive), while mappings to the one-element set do exist, and returning the only element of this set yields zero information, that is, "nothing". This is equivalent to void in such imperative languages as C++.

In MeTTa, the empty expression () is used for the unit value, which is the only instance of the type (->). A function, which doesn't return anything meaningful but which is still supposed to be a valid function, should return () unless a custom unit type is defined for it.

In practice, this () value is used as the return type for grounded functions with side effects (unless these side effects are not described in a special way, e.g., with monads). For example, the function add-atom adds an atom to the Space, and returns ().

When it is necessary to execute such a side-effect function and then to return some value, or to chain it with subsequent execution of another side-effect function, it is convenient to use the following construction based on let: (let () (side-effect-function) (evaluate-next)). If (side-effect-function) returns (), it is matched with the pattern () in let-expression (one can use a variable instead of () as well), and then (evaluate-next) is executed.

Let us consider a simple knowledge base for a personal assistant system. The knowledge base contains information about the tasks the user is supposed to do. A new atom in this context would be a new task.


(= (message-to-user $task)
   (Today you have $task))
(= (add-task-and-notify $task)
    (let () (add-atom &self (TASK $task))
            (message-to-user $task))
)
! (get-type add-atom) ; (-> hyperon::space::DynSpace Atom (->))
! (add-task-and-notify (Something to do))
! (match &self (TASK $t) $t) # (Somthing to do)
Output
[(-> SpaceType Atom (->))]
[(Today you have (Something to do))]
[(Something to do)]
The add-task-and-notify function adds a $task atom into the current Space using the add-atom function and then calls another function which returns a message to notify the user about the new task. Please, notice the type signature of add-atom.

Standard Library Overview
In this section we will look at the main functions of the standard library, which are part of the standard distribution of MeTTa.

Basic grounded functions
Arithmetic operators and Number type
Arithmetic operations in MeTTa are grounded functions and use the prefix notation where the operator comes before the operands. MeTTa arithmetic works with atoms of Number type, which can store floating-point numbers as well as integers under the hood, and you can mix them in your calculations. The type of binary arithmetic operations is (-> Number Number Number).


; Addition
! (+ 1 3) ; 4

; Subtraction
! (- 6 2.2) ; 3.8

; Multiplication
! (* 7.3 9) ; 65.7

; Division
! (/ 25 5) ; 5 or 5.0

; Modulus
! (% 24 5) ; 4
Output
[4]
[3.8]
[65.7]
[5]
[4]
In the current implementation arithmetic operations support only two numerical arguments, expressions with more than two arguments like !(+ 1 2 3 4) will result in a type error (IncorrectNumberOfArguments). One should use an explicit nested expression in that case


! (+ 1 (+ 2 (+ 3 4))) ; 10
! (- 8 (/ 6.4 4)) ; 6.4
Output
[10]
[6.4]
Numbers in MeTTa are presented as grounded atoms with the predefined Number type. Evaluation of ill-typed expressions produces an error expression. Notice, however, that arithmetic expressions with atoms of %Undefined% type will not be reduced.


! (+ 2 S) ; (+ 2 S)
! (+ 2 "8") ; BadType
Output
[(+ 2 S)]
[(Error "8" BadType)]
Other common mathematical operations like sqr, sqrt, abs, pow, min, max, log2, ln, etc. are not included in the standard library as grounded symbols at the moment. But they can be imported from Python directly.

Comparison operations
Comparison operations implemented in stdlib are also grounded operations. There are four operations <, >, <=, >= of (-> Number Number Bool) type.


; Less than
! (< 1 3)

; Greater than
! (> 3 2)

; Less than or equal to
! (<= 5 6.2)

; Greater than or equal to
! (>= 4 (+ 2 (* 3 5)))
Output
[True]
[True]
[True]
[False]
Once again, passing ordinary symbols to grounded operations will not cause errors, and the expression simply remains unreduced, if it type-checks. Thus, it is generally a good practice to ensure the types of atoms being compared are what the comparison operators expect to prevent unexpected results or errors.


! (> $x (+ 8 2)) ; Inner expression is reduced, but the outer is not
! (>= 4 (+ Q 2)) ; Reduction stops in the inner expression
(: R CustomType)
! (>= 4 R) ; BadType
Output
[(> $x 10)]
[(>= 4 (+ Q 2))]
[(Error R BadType)]
The == operation is implemented to work with both grounded and symbol atoms and expressions (while remaining a grounded operation). Its type is (-> $t $t Bool). Its arguments are evaluated before executing the operation itself.


! (== 4 (+ 2 2)) ; True
! (== "This is a string" "Just a string") ; False
! (== (A B) (A B)) ; True
! (== (A B) (A (B C))) ; False
Output
[True]
[False]
[True]
[False]
Unlike < or >, == will not remain unreduced if one of its arguments is grounded, while another is not. Instead, it will return False if the expression is well-typed.


! (== 4 (+ Q 2)) ; False
(: R CustomType)
! (== 4 R) ; BadType
Output
[False]
[(Error R BadType)]
Logical operations and Bool type
Logical operations in MeTTa can be (and with some build options are) implemented purely symbolically. However, the Python version of stdlib contains their grounded implementation for better interoperability with Python. In particular, numeric comparison operations directly execute corresponding operations in Python and wrap the resulting bool value into a grounded atom. The grounded implementation is intended for subsymbolic and purely functional processing, while custom logic systems for reasoning are supposed to be implemented symbolically in MeTTa itself.

Logical operations in stdlib deal with True and False values of Bool type, and have signatures (-> Bool Bool) and (-> Bool Bool Bool) for unary and binary cases.


; Test if both the given expressions are True
! (and (> 4 2) (== "This is a string" "Just a string")) ; False

; Test if any of the given expressions is True
! (or (> 4 2) (== "This is a string" "Just a string")) ; True

; Negates the result of a given Bool value
! (not (== 5 5)) ; False
! (not (and (> 4 2) (< 4 3))) ; True

Output
[False]
[True]
[False]
[True]

Console output and debugging
All values obtained during evaluation of the MeTTa program or script are collected and returned. The whole program can be treated as a function. If a stand-alone program is executed via a command-line runner or REPL these results are printed at the end. This printing will not happen if MeTTa is used via its API.

However, MeTTa has two functions to send information to the console output: println! and trace!. They can be used by developers for displaying messages and logging information during the evaluation process, in particular, for debugging purposes.

Print a line
The println! function is used to print a line of text to the console. Its type signature is (-> %Undefined% (->)).

The function accepts only a single argument, but multiple values can be printed by enclosing them within parentheses to form a single atom:


! (println! "This is a string")
! (println! ($v1 "string" 5))
Output
[STDOUT] "This is a string"
[STDOUT] ($v1 "string" 5)
[()]
[()]
Note that println! returns the unit value (). Beside printing to stdout, the program will return two units due to println! evaluation.

The argument of println! is evaluated before println! is called (its type is not Atom but %Undefined%), so the following code


(Parent Bob Ann)
! (match &self (Parent Bob Ann) (Ann is Bob`s child))
! (println! (match &self (Parent Bob Ann) (Bob is Ann`s parent)))
Output
<empty string>
will print (Bob is Ann's parent) to stdout. Note that this result is printed before all the evaluation results (starting with the match expressions) are returned.

Trace log
trace! accepts two arguments, the first is the atom to print, and the second is the atom to return. Both are evaluated before passing to trace!, which type is (-> %Undefined% $a $a), meaning that the reduced type of the whole trace! expression is the same as the reduced type of the second argument:


! (get-type (trace! (Expecting 3) (+ 1 2))) ; Number
Output
[Number]
trace! can be considered as a syntactic sugar for the following construction using println! and let


(: my-trace (-> %Undefined% $a $a))
(= (my-trace $out $res)
   (let () (println! $out) $res))
! (my-trace (Expecting 3) (+ 1 2))
Output
[STDOUT] (Expecting 3)
[3]
It can be used as a debugging tool that allows printing out a message to the terminal, along with valuating an atom.


(Parent Bob Ann)
! (trace! "Who is Anna`s parent?" ; print this expression
   (match &self (Parent $x Ann)
          ($x is Ann`s parent)))  ; return the result of this expression
!(trace! "Who is Bob`s child?"  ; print this expression
   (match &self (Parent Bob $x)
          ($x is Bob`s child))) ; return the result of this expression
Output
[STDOUT] "Who is Anna`s parent?"
[STDOUT] "Who is Bob`s child?"
[(Bob is Ann`s parent)]
[(Ann is Bob`s child)]
The first argument does not have to be a pure string, which makes trace! work fine on its own


(Parent Bob Ann)
! (trace! ((Expected: (Bob is Ann`s parent))
           (Got: (match &self (Parent $x Ann) ($x is Ann`s parent)))
          )
   ())
Output
[STDOUT] ((Expected: (Bob is Ann`s parent)) (Got: (Bob is Ann`s parent)))
[()]
Quote
Quotation was already introduced as a tool for evaluation control. Let us recap that quote is just a symbol with (-> Atom Atom) type without equalities (i.e., a constructor). In some versions of MeTTa and its stdlib, quote can be defined as (= (quote $atom) NotReducible), where the symbol NotReducible explicitly tells the interpreter that the expression should not be reduced.

The following is the basic example of the effect of quote:


(Fruit apple)
(= (fruit $x)
   (match &self (Fruit $x) $x))
! (fruit $x) ; apple
! (quote (fruit $x)) ; (quote (fruit $x))
Output
[apple]
[(quote (fruit $x))]
There is a useful combination of trace!, quote, and let for printing an expression together with its evaluation result, which is then returned.


(: trace-eval (-> Atom Atom))
(= (trace-eval $expr)
   (let $result $expr
        (trace! (EVAL: (quote $expr) --> $result)
                $result)))
(Fruit apple)
(= (fruit $x)
   (match &self (Fruit $x) $x))
; (EVAL: (quote (fruit $x)) --> apple) is printed to stdout
! (Overall result is (trace-eval (fruit $x))) ; (Overall result is apple)
Output
[(Overall result is (let $result#7509 (fruit $x) (trace! (EVAL: (quote (fruit $x)) --> $result#7509) $result#7509)))]
In this code, trace-eval accepts $expr of Atom type, so it is not evaluated before getting to trace-eval. (let $result $expr ...) stores the result of evaluation of $expr into $result, and then prints both of them using trace! ((quote $expr) is used to avoid reduction of $expr before passing to trace!) and returns $result. The latter allows wrapping trace-eval into other expressions, which results in the behavior, which would take place without such wrapping, except for additional console output.

Another pattern of using trace! with quote and let is to add tracing to the function itself. We first calculate the result (if needed), and then use trace! to print some debugging information and return the result:


(= (add-bin $x)
   (let $r (+ $x 1)
        (trace! (quote ((add-bin $x) is $r))
                $r)))
(= (add-bin $x)
   (trace! (quote ((add-bin $x) is $x))
           $x))
; (quote ((add-bin 1) is 1)) and (quote ((add-bin 1) is 2)) will be printed
! (add-bin 1) ; [1, 2]
Output
[STDOUT] (quote ((add-bin 1) is 2))
[STDOUT] (quote ((add-bin 1) is 1))
[1, 2]
Without quotation an atom such as (add-bin $x) evaluated from trace! would result in an infinite loop, but quote prevents the wrapped atom from being interpreted.

In the following code (test 1) would be evaluated from trace! and would result in an infinite loop


(= (test 1) (trace! (test 1) 1))
(= (test 1) (trace! (test 0) 0))
! (test 1)
Asserts
MeTTa has a couple of assert operations that allow a program to check if a certain condition is true and return an error-expression if it is not.

assertEqual compares (sets of) results of evaluation of two expressions. Its type is (-> Atom Atom Atom), so it interprets expressions internally and can compare erroneous expressions. If sets of results are equal, it outputs the unit value ().


(Parent Bob Ann)
! (assertEqual
   (match &self (Parent $x Ann) $x)
   (unify (Parent $x Ann) (Parent Bob $y) $x Failed)) ; ()
! (assertEqual (+ 1 2) 3) ; ()
! (assertEqual (+ 1 2) (+ 1 4)) ; Error-expression
Output
[()]
[()]
[(Error (assertEqual (+ 1 2) (+ 1 4)) "\nExpected: [5]\nGot: [3]\nMissed results: 5\nExcessive results: 3")]
While assertEqual is convenient when we have two expressions to be reduced to the same result, it is quite common that we want to check if the evaluated expression has a very specific result. Imagine the situation when one wants to be sure that some expression, say (+ 1 x), is not reduced. It will make no sense to use (assertEqual (+ 1 x) (+ 1 x)).

Also, if the result of evaluation is nondeterministic, and the set of supposed outcomes is known, one would need to turn this set into a nondeterministic result as well in order to use assertEqual. It can be done with superpose, but both issues are covered by the following assert function.

assertEqualToResult has the same type as assertEqual, namely (-> Atom Atom Atom), and it evaluates the first expression. However, it doesn't evaluate the second expression, but considers it a set of expected results of the first expression.


(Parent Bob Ann)
(Parent Pam Ann)
! (assertEqualToResult
    (match &self (Parent $x Ann) $x)
    (Bob Pam))  ; ()
(= (bin) 0)
(= (bin) 1)
! (assertEqualToResult (bin) (0 1)) ; ()
! (assertEqualToResult (+ 1 2) (3)) ; ()
! (assertEqualToResult
    (+ 1 untyped-symbol)
   ((+ 1 untyped-symbol))) ; ()
! (assertEqualToResult (+ 1 2) ((+ 1 2))) ; Error
Output
[()]
[()]
[()]
[()]
[(Error (assertEqualToResult (+ 1 2) ((+ 1 2))) "\nExpected: [(+ 1 2)]\nGot: [3]\nMissed results: (+ 1 2)\nExcessive results: 3")]
Let us notice a few things:

We have to take the result into brackets, e.g., (assertEqualToResult (+ 1 2) (3)) vs (assertEqual (+ 1 2) 3), because the second argument of assertEqualToResult is a set of results even if this set contains one element.
As a consequence, a non-reducible expression also gets additional brackets as the second argument, e.g., ((+ 1 untyped-symbol)). It is also a one-element set of the results.
The second argument is indeed not evaluated. The last assert yields an error, because (+ 1 2) is reduced to 3. Notice 3 as what we got instead of expected (for the sake of the example) (+ 1 2).

Handling nondeterministic results
Superpose
In previous tutorials we saw that match along with any other function can return multiple (nondeterministic) as well as empty results. If you need to get a nondeterministic result explicitly, use the superpose function, which turns a tuple into a nondeterministic result. It is an stdlib function of (-> Expression Atom) type.

However, it is typically recommended to avoid using it. For example, in the following program


(= (bin) 0)
(= (bin) 1)
(= (bin2) (superpose (0 1)))
! (bin) ; [0, 1]
! (bin2) ; [0, 1]
Output
[0, 1]
[1, 0]
bin and bin2 do similar job. However, bin is evaluated using one equality query, while bin2 requires additional evaluation of superpose. Also, one may argue that bin is more modular and more suitable for meta-programming and evaluation control.

One may want to use superpose to execute several operations. However, the order of execution is not guaranteed. And again, one can try thinking about writing multiple equalities for a function, inside which superpose seems to be suitable.

However, superpose can still be convenient in some cases. For example, one can pass nondeterministic expressions to any function (both grounded and symbolic, built-in and custom) and get multiple results. In the following example, writing a nondeterministic function returning 3, 4, 5 would be inconvenient:


! (+ 2 (superpose (3 4 5))) ; [5, 6, 7]
Output
[7, 6, 5]
Here, nondeterminism works like a map over a set of elements.

Another example, where using superpose explicitly is useful is for checking a set of nondeterministic results with assertEqual, when both arguments still require evaluation (so assertEqualToResult is not convenient to apply). In the following example, we want to check that we didn't forget any equality for (color), but we may not be interested what exact value they are reduced to (i.e., whether (ikb) is reduced to international-klein-blue or something else).


(= (ikb) international-klein-blue)
(= (color) green)
(= (color) yellow)
(= (color) (ikb))

!(assertEqual
  (match &self (= (color) $x) $x)
  (superpose ((ikb) yellow green))) ; ()
!(assertEqualToResult
   (match &self (= (color) $x) $x)
  ((ikb) yellow green)) ; Error
Output
[()]
[(Error (assertEqualToResult (match ModuleSpace(GroundingSpace-top) (= (color) $x) $x) ((ikb) yellow green)) "\nExpected: [(ikb), yellow, green]\nGot: [green, yellow, international-klein-blue]\nMissed results: (ikb)\nExcessive results: international-klein-blue")]
Empty
As mentioned above, in MeTTa, functions can return empty results. This is a natural consequence on the evaluation semantics based on queries, which can find no matches. Sometimes, we may want to force a function to "return" an empty result to abort a certain evaluation branch, or to explicitly represent it to analyze this behavior on the meta-level.

(superpose ()) will exactly return the empty set of results. However, stdlib provide (empty) function to do the same in a clearer and stable way. Some versions may also use Empty as a symbol to inform the interpreter about the empty result, which may differ on some level from calling a grounded function, which really returns an empty set. (empty) is supported more widely at the moment, so we use it here.

(empty) could be useful in the construction of the asserts (assertEqual (...) (empty)), but (assertEqualToResult (...) ()) can also work.


(Parent Bob Ann)
! (assertEqual
    (match &self (Parent Tom $x) $x)
    (empty)) ; ()
! (assertEqualToResult
    (match &self (Parent Tom $x) $x)
    ()) ; ()
Output
[()]
[()]
Since expressions without suitable equalities remain unreduced in MeTTa, (empty) can be used to alter this behavior, when desirable, e.g.


(= (eq $x $x) True)
! (eq a b) ; (eq a b)
(= (eq $x $y) (empty))
! (eq a b) ; no result
Output
[(eq a b)]
[]
(empty) can be used to turn a total function such as if or unify into a partial function, when we have no behavior for the else-branch, and we don't want the expression to remain unreduced.

Let us note that there is some convention in how the interpreter processes empty results. If the result of match for equality query is empty, the interpreter doesn't reduce the given expression (it transforms the empty result of such queries to NotReducible), but if a grounded function returns the empty result, it is treated as partial. When a grounded function application is not reduced, e.g. (+ 1 undefined-symbol), because the function returns not the empty result, but NotReducible. This behavior may be refined in the future, but the possibility to have both types of behavior (a partial function is not reduced and evaluation continues or it returns no result stopping further evaluation) will be supported.

From nondeterministic viewpoint, (empty) removes an evaluation branch. If we consider all the results as a collection, (empty) can be used for its filtering. In the following program, (color) and (fruit) produce nondeterministic "collections" of colors and fruits correspondingly, while filter-prefer is a partially defined id function, which can be used to filter out these collections.


(= (color) red)
(= (color) green)
(= (color) blue)
(= (fruit) apple)
(= (fruit) banana)
(= (fruit) mango)
(= (filter-prefer blue) blue)
(= (filter-prefer banana) banana)
(= (filter-prefer mango) mango)
(= (filter-prefer $x) (empty))
! (filter-prefer (color)) ; [blue]
! (filter-prefer (fruit)) ; [mango, banana]
Output
[blue]
[mango, banana]
In case of recursion, (empty) can prune branches, which don't satisfy some conditions as shown in this example.

Collapse
Nondeterminism is an efficient way to map and filter sets of elements as well as to perform search. However, nondeterministic branches do not "see" each other, while we may want to get the extreme element or just to count them (or, more generally, fold over them). That is, we may need to collect the results in one evaluation branch.

Reverse operation to superpose is collapse, which has the type (-> Atom Expression). It converts a nondeterministic result into a tuple.

collapse is a grounded function, which runs the interpreter on the given atom and wraps the returned results into an expression.


(= (color) red)
(= (color) green)
(= (color) blue)
! (color) ; three results: [blue, red, green]
! (collapse (color)) ; one result: [(blue red green)]
Output
[red, green, blue]
[(red green blue)]
Here we've got a nondeterministic result [blue, red, green] from the color function and converted it into one tuple [(blue red green)] using collapse.

The superpose function reverts the collapse result


(= (color) green)
(= (color) yellow)
(= (color) red)
! (color) ; [green, yellow, red]
! (collapse (color)) ; [(green yellow red)]
! (let $x (collapse (color))
    (superpose $x))  ; [green, yellow, red]
! (superpose (1 2 3)) ; [1, 2, 3]
! (collapse (superpose (1 2 3)))
! (let $x (superpose (1 2 3)) ; [(1 2 3)]
    (collapse $x))    ; [(1), (2), (3)]
Output
[green, yellow, red]
[(green yellow red)]
[green, yellow, red]
[1, 2, 3]
[(1 2 3)]
[(3), (2), (1)]
The color function gives the nondeterministic result [green, yellow, red] (the order of colors may vary). The collapse function converts it into a tuple [(green yellow red)]. And finally the superpose function in let converts a tuple back into the nondeterministic result [red, green, yellow]. The order of colors may change again due to nondeterminism.

Note that we cannot call collapse inside superpose, because collapse will not be executed before passing to superpose and will be considered as a part of the input tuple. In contrary, we cannot call superpose outside collapse, because it will cause collapse to be called separately for each nondeterministic branch produced by superpose instead of collecting these branches inside collapse.

Working with spaces
Space API
Spaces can have different implementations, but should satisfy a certain API. This API includes pattern-matching (or unification) functionality. match is an stdlib function, which calls a corresponding API function of the given space, which can be different from the program space.

Let us recap that the type of match is (-> hyperon::space::DynSpace Atom Atom %Undefined%). The first argument is a space (or, more precisely, a grounded atom referring to a space) satisfying the Space API. The second argument is the input pattern to be unified with expressions in the space, and the third argument is the output pattern, which is instantiated for every found match. match can produce any number of results starting with zero, which are treated nondeterministically.

The basic use of match was already covered before, while its use with custom spaces will be described in other tutorials, since these spaces are not the part of stdlib. However, the Space API includes additional components, which are utilized by such stdlib functions as add-atom and remove-atom.

Adding atoms
The content of spaces can be not only defined statically in MeTTa scripts, but can also be modified at runtime by programs residing in the same or other spaces.

The function add-atom adds an atom into the Space. Its type is (-> hyperon::space::DynSpace Atom (->)). The first argument is an atom referring some Space, to which an atom provided as the second argument will be added. Since the type of the second argument is Atom, the added atom is added as is without reduction.

In the following program, add-foo-eq is a function, which adds an equality for foo to the program space whenever called. Then, it is checked that the expressions are added to the space without reduction.


(: add-foo-eq (-> Atom (->)))
(= (add-foo-eq $x)
   (add-atom &self (= (foo) $x)))
! (foo) ; (foo) - not reduced
! (add-foo-eq (+ 1 2)) ; () - OK
! (add-foo-eq (+ 3 4)) ; () - OK
! (foo) ; [3, 7]
! (match &self (= (foo) $x)
    (quote $x)) ; [(quote (+ 1 2)), (quote (+ 3 4))]
Output
[(foo)]
[()]
[()]
[3, 7]
[(quote (+ 1 2)), (quote (+ 3 4))]
If it is desirable to add a reduced atom without additional wrappers (e.g., like add-foo-eq but without Atom type for the argument), then add-reduct can be used:


! (add-reduct &self (= (foo) (+ 3 4))) ; ()
! (foo) ; 7
! (match &self (= (foo) $x)
    (quote $x)) ; (quote 7)
Output
[()]
[7]
[(quote 7)]
Removing atoms
The function remove-atom removes an atom from the AtomSpace without reducing it. Its type is (-> hyperon::space::DynSpace Atom (->)).

The first argument is a reference to the space from which the Atom needs to be removed, the second is the atom to be removed. Notice that if the given atom is not in the space, remove-atom currently neither raises a error nor returns the empty result.


(Atom to remove)
! (match &self (Atom to remove) "Atom exists") ; "Atom exists"
! (remove-atom &self (Atom to remove)) ; ()
! (match &self (Atom to remove) "Unexpected") ; nothing
! (remove-atom &self (Atom to remove)) ; ()
Output
["Atom exists"]
[()]
[]
[()]
Combination of remove-atom and add-atom can be used for graph rewriting. Consider the following example.


(link A B)
(link B C)
(link C A)
(link C E)

! (match &self (, (link $x $y)
                  (link $y $z)
                  (link $z $x))
               (let () (remove-atom &self (link $x $y))
                       (add-atom &self (link $y $x)))
  ) ; [(), (), ()]
! (match &self (link $x $y)
    (link $x $y)) ; [(link A C), (link C B), (link B A), (link C E)]
Output
[(), (), ()]
[(link A C), (link C E), (link C B), (link B A)]
Here, we find entries (link _ _), which form three-element loops, and revert the direction of links in them. Let us note that match returns three unit results, because the loop can start from any of such entries. All of them are reverted (only (link C E) remains unchanged). Also, in the current implementation, match first finds all the matches, and then instantiates the output pattern with them, which is evaluated outside match. If remove-atom and add-atom would be executed right away for each found matching, the condition of circular links would be broken after the first rewrite. This behavior can be space-specific, and is not a part of MeTTa specification at the moment. This can be changed in the future.

New spaces
It is possible to create other spaces with the use of new-space function from stdlib. Its type is (-> hyperon::space::DynSpace), so it has no arguments and returns a fresh space. Creating new spaces can be useful to keep the program space cleaner, or to simplify queries.

If we just run (new-space) like this


! (new-space)
Output
[GroundingSpace-0x56200ca48a28]
we will get something like GroundingSpace-0x10703b398 as a textual representation space atom. But how can we refer to this space in other parts of the program? Notice that the following code will not work as desired


(= (get-space) (new-space))
! (add-atom (get-space) (Parent Bob Ann)) ; ()
! (match (get-space) (Parent $x $y) ($x $y)) ; nothing
Output
[()]
[]
because (get-space) will create a brand new space each time.

One workaround for this issue in a functional programming style is to wrap the whole program into a function, which accepts a space as an input and passes it to subfunctions, which need it:


(= (main $space)
   (let () (add-atom $space (Parent Bob Ann))
     (match $space (Parent $x $y) ($x $y))
   )
)
! (main (new-space)) ; (Bob Ann)
Output
[(Bob Ann)]
This approach has its own merits. However, a more direct fix for (= (get-space) (new-space)) would be just to evaluate (new-space) before adding it to the program:


! (add-reduct &self (= (get-space) (new-space))) ; ()
! (add-atom (get-space) (Parent Bob Ann)) ; ()
! (get-space) ; GroundingSpace-addr
! (match (get-space) (Parent $x $y) ($x $y)) ; (Bob Ann)
Output
[()]
[()]
[GroundingSpace-0x55bc2f426ce8]
[(Bob Ann)]
That is, (new-space) is evaluated to a grounded atom, which wraps a newly created space. Other elements of (= (get-space) (new-space)) are not reduced. Instead of add-reduct, one could use the following more explicit code


! (let $space (new-space)
    (add-atom &self (= (get-space) $space)))
which also ensured that nothing is reduced except (new-space).

Creating tokens
Why can't we refer to the grounded atom, which wraps the created space? Indeed, we can represent such grounded atoms as numbers or operations over them in the code. And what is about &self?

In fact, they are turned into atoms from their textual representation by the parser, which knows a mapping from textual tokens (defined with the use of regular expressions) to constructors of corresponding grounded atom. Basically, &self is replaced with the grounded atom wrapping the program space by the parser before it gets inside the interpreter.

Parsing is explained in more detail in another tutorial, while here we focus on the stdlib function bind!.

bind! registers a new token which is replaced with an atom during the parsing of the rest of the program. Its type is (-> Symbol %Undefined% (->)).

The first argument has type Symbol, so technically we can use any valid symbol as the token name, but conventionally the token should start with &, when it is bound to a custom grounded atom, to distinguish it from symbols. The second argument is the atom, which is associated with the token after reduction. This atom should not necessarily be a grounded atom. bind! returns the unit value () similar to println! or add-atom.

Consider the following program:


(= (get-hello) &hello)
! (bind! &hello (Hello world)) ; ()
! (get-metatype &hello) ; Expression
! &hello ; (Hello world)
! (get-hello) ; &hello
Output
[()]
[Expression]
[(Hello world)]
[&hello]
We first define the function (get-hello), which returns the symbol &hello. Then, we bind the token &hello to the atom (Hello world). Note that the metatype of &hello is Expression, because it is replaced by the parser and gets to the interpreter already as (Hello world). ! &hello is expectedly (Hello world). Once again, &hello is not reduced to (Hello world) by the interpreter. It is replaced with it by the parser. It can be seen by the fact that (get-hello) returns &hello as a symbol, because it was parsed and added to the program space before bind!.

bind! might be tempting to use to refer to some lengthy constant expressions, e.g.


! (bind! &x (foo1 (foo2 3) 45 (A (v))))
! &x
Output
[()]
[(foo1 (foo2 3) 45 (A (v)))]
However, this lengthy expression will be inserted to the program in place of every occurrence of &x. However, let us note again that the second argument of bind! is evaluated before bind! is called, which is especially important with functions with side effects. For example, the following program will print "test" only once, while &res will be simply replaced with ().


! (bind! &res (println! "test"))
! &res
! &res
Output
[STDOUT] "test"
[()]
[()]
[()]
Using bind! for unique grounded atoms intensively used in the program can be more reasonable. Binding spaces created with (new-space) to tokens is one of possible use cases:


! (bind! &space (new-space)) ; ()
! (add-atom &space (Parent Bob Ann)) ; ()
! &space ; GroundingSpace-addr
! (match &space (Parent $x $y) ($x $y)) ; (Bob Ann)
! (match &self (Parent $x $y) ($x $y)) ; empty
Output
[()]
[()]
[GroundingSpace-0x55bc29f7df88]
[(Bob Ann)]
[]
However, if spaces are created dynamically depending on runtime data, bind! is not usable.

Imports
Stdlib has operations for importing scripts and modules. One such operation is import!. It accepts two arguments. The first argument is a symbol, which is turned into the token for accessing the imported module. The second argument is the module name. For example, the program from the tutorial could be split into two scripts - one containing knowledge, and another one querying it.


; people_kb.metta
(Female Pam)
(Male Tom)
(Male Bob)
(Female Liz)
(Female Pat)
(Female Ann)
(Male Jim)
(Parent Tom Bob)
(Parent Pam Bob)
(Parent Tom Liz)
(Parent Bob Ann)
(Parent Bob Pat)
(Parent Pat Jim)

; main.metta
! (import! &people people_kb)
(= (get-sister $x)
   (match &people
     (, (Parent $y $x)
        (Parent $y $z)
        (Female $z))
     $z
   )
)
! (get-sister Bob)
Here, (import! &people people_kb) looks similar to (bind! &people (new-space)), but import! fills in the loaded space with atoms from the script. Let us note that import! does more work than just loading the script into a space. It interacts with the module system, which is described in another tutorial.

&self can be passed as the first argument to import!. In this case, the script or module will still be loaded into a separate space, but the atom wrapping this space will be inserted to &self. Pattern matching queries encountering such atoms will delegate queries to them (with the exception, when the space atom itself matches against the query, which happens, when this query is just a variable, e.g., $x). Thus, it works similar to inserting all the atoms to &self, but with some differences, when importing the same module happens multiple times, say, in different submodules.

One may use get-atoms method to see that the empty MeTTa script is not that empty and contains the stdlib space(s). Note that the result get-atoms will be reduced. Thus, it is not recommended to use in general.


! (get-atoms &self)
Output
[]
Some space atoms are present in the seemingly empty program since some modules are pre-imported. Indeed, one can find, say, if definition in &self, which actually resides in the stdlib space inserted into &self as an atom


! (match &self
          (= (if $cond $then $else) $result)
   (quote (= (if $cond $then $else) $result))
  )
Output
[(quote (= (if True $result $else) $result)), (quote (= (if False $then $result) $result))]
mod-space! returns the space of the module (and tries to load the module if it is not loaded into the module system). Thus, we can explore the module space explicitly.


! (mod-space! stdlib)
! (match (mod-space! stdlib)
          (= (if $cond $then $else) $result)
   (quote (= (if $cond $then $else) $result))
  )
Output
[ModuleSpace(GroundingSpace-top:stdlib)]
[]

Control flow
MeTTa has several specific constructs that allow a program to execute different parts of code based either on pattern matching or logical conditions.

if
if was already covered in this tutorial. But let us recap it as a part of stdlib.

The if statement implementation in MeTTa can be the following function


(: if (-> Bool Atom Atom $t))
(= (if True $then $else) $then)
(= (if False $then $else) $else)
Here, the first argument (condition) is Bool, which is evaluated before executing the equality-query for if.

The next two arguments are not evaluated and returned for the further evaluation depending on whether the first argument is matched with True or False.

The basic use of if in MeTTa is similar to that in other languages:


(= (foo $x)
   (if (>= $x 0)
       (+ $x 10)
       (* $x -1)
   )
)
! (foo 1)  ; 11
! (foo -9) ; 9
Output
[11]
[9]
Here we have a function foo that adds 10 to the input value if it's grater or equal 0, and multiplies the input value by -1 otherwise. The expression (>= $x 0) is the first argument of the if function, and it is evaluated to a Bool value. According to that value the expression (+ $x 10) or (* $x -1) is returned for the final evaluation, and we get the result.

In contrast to other languages, one can pass a variable to if and it will be matched against equalities with both True and False. Consider the following example


! (if $x (+ 6 1) (- 7 2))
(= (foo $b $x)
   (if $b
       (+ $x 10)
       (* $x -1)
   )
)
! ((foo $b 1) $b) ; [(-1 False), (11 True)]
Output
[7, 5]
[(11 True), (-1 False)]
foo accepts the condition for if, and when we pass a variable, both branches are evaluated with the corresponding binding for $b.

if can also remain unreduced:


! (if (> $x 0) (+ $x 5) (- $x 5))
Output
[(if (> $x 0) (+ $x 5) (- $x 5))]
In this expression, (> $x 0) remains unreduced. Its overall type is Bool, but it can't be directly matched against neither True nor False. Thus, no equality is applied.

let
let has been briefly described in another tutorial. Here, we will recap it.

The let function is utilized to establish temporary variable bindings within an expression. It allows introducing variables, assign values to them, and then use these values within the scope of the let block.

Once the let block has run, these variables cease to exist and any previous bindings are re-established. Depending on the interpreter version, let can be either a basic grounded function, or be implemented using other primitives. Let us consider its type


! (get-type let)
Output
[(-> Atom %Undefined% Atom %Undefined%)]
The first argument of let is a pattern of Atom type, which is not evaluated. The second argument is the value, which is reduced before being passed to let The third parameter is an Atom again. An attempt to unify the first two arguments is performed. If it succeeds, the found bindings are substituted to the third argument, which is then evaluated. Otherwise, the empty result is returned.

Consider the following example:


(= (test 1) 1)
(= (test 1) 0)
(= (test 2) 2)

! (let $W (test $X) (println! ("test" $X => $W)))
Output
[STDOUT] ("test" 1 => 1)
[STDOUT] ("test" 1 => 0)
[STDOUT] ("test" 2 => 2)
[(), (), ()]
The code above will print:


("test" 1 => 1)
("test" 1 => 0)
("test" 2 => 2)
and return three unit results produced by println!. It can be seen that variables from both the first and the second arguments can appear in the third argument.

The following example shows the difference between the first two arguments.


(= (test 1) 2)
! (let 2 (test 1) YES) ; YES
! (let (test 1) 2 NO ) ; empty
Output
[YES]
[]
In case of (let 2 (test 1) YES), (test 1) is evaluated to 2, and it can be unified with the first argument, which is also 2. In case of (let (test 1) 2 NO), (test 1) is not reduced, and it cannot be unified (as a pattern) with 2, so the overall result is empty.

This example also shows that variables are not mandatory in let. What is needed is the possibility to unify the arguments. This allows using let for chaining operations, and this chaining can be conditional if the first operation returns some value, e.g.


(= (is-frog Sam) True)
(= (print-if-frog $x)
   (let True (is-frog $x)
     (println! ($x is frog!))))
! (print-if-frog Sam) ; ()
! (print-if-frog Ben) ; empty
Output
[STDOUT] (Sam is frog!)
[()]
[]
Another basic use of let is to calculate values for passing them to functions accepting arguments of Atom type, for example:


(Sam is 34 years old)
! (match &self ($who is (+ 20 14) years old) $who) ; empty
! (let $r (+ 20 14)
   (match &self ($who is $r years old) $who)) ; Sam
Output
[]
[Sam]
Since the first argument can be not only a variable or a concrete value, but also an expression, let can be used for deconstructing expressions


(= (fact Sam) (age 34))
(= (fact Sam) (color green))
(= (fact Tom) (age 14))
! (let (age $r) (fact $who)
   ($who is $r)) ; [(Tom is 14), (Sam is 34)]
Output
[(Tom is 14), (Sam is 34)]
The branches not corresponding to the (age $r) pattern are filtered out.

let*
When several consecutive substitutions are required, let* can be used for convenience. The first argument of let* is Expression, which elements are the required substitutions, while the second argument is the resulting expression. In the following example, several values are subsequently calculated, and let* allows making it more readable (notice also how pattern matching helps to calculate minimum and maximum values together with their absolute difference in one if).


(Sam is 34)
(Tom is 14)
(= (person-by-age $age)
   (match &self ($who is $age) $who))
(= (persons-of-age $a $b)
   (let* ((($age-min $age-max $diff)
           (if (< $a $b)
               ($a $b (- $b $a))
               ($b $a (- $a $b))))
          ($younger (person-by-age $age-min))
          ($older   (person-by-age $age-max))
         )
         ($younger is younger than $older by $diff years))
)
! (persons-of-age 34 14)
Output
[(Tom is younger than Sam by 20 years)]
Another case, for which let* can be convenient, is the consequent execution of side-effect functions, e.g.


(Sam is 34)
(= (age++ $who)
   (let* (($age (match &self ($who is $a) $a))
          ( ()  (println! (WAS: ($who is $age))))
          ( ()  (remove-atom &self ($who is $age)))
          ( ()  (add-reduct &self ($who is (+ $age 1))))
          ($upd (match &self ($who is $a) $a))
          ( ()  (println! (NOW: ($who is $upd)))))
        $upd
   )
)
! (age++ Sam) ; 35
Output
[STDOUT] (WAS: (Sam is 34))
[STDOUT] (NOW: (Sam is 35))
[35]
case
Another type of multiway control flow mechanism in MeTTa is the case function, which was briefly mentioned in the tutorial. It turns let around and subsequently tests multiple pattern-matching conditions for the given value. This value is provided by the first argument. While the formal argument type is Atom, it will be evaluated. The second argument is a tuple, which elements are pairs mapping condition patterns to results.


(Sam is Frog)
(Apple is Green)
(= (test $who)
   (case (match &self ($who is $x) $x)
    (
        (42   "The answer is 42!")
        (Frog "Do not ask me about frogs")
        ($a   ($who is $a))
    )))
! (test Sam) ; "Do not ask me about frogs"
! (test Apple) ; (Apple is Green)
! (test Car) ; empty
Output
["Do not ask me about frogs"]
[(Apple is Green)]
[]
Cases are processed sequentially from the first to the last. In the example above, $a condition will always be matched, so it is put at the end, and the corresponding branch is triggered, when all the previous conditions are not met. Note, however, that $a is not matched against the empty result in the last case.

In order to handle such cases, one can use Empty symbol as a case pattern (in some versions of the interpreter, Empty is the dedicated symbol which (empty) is evaluated to). The following code should return "Input was really empty":


! (case (empty)
    ((Empty "Input was really empty")
    ($_   "Should not be the case"))
  )
Output
["Input was really empty"]
In the current version of MeTTa (v0.1.12), Empty can be matched against a variable. This means that the result of (empty) can be matched against $. In this situation, if we want to catch Empty case, we need to place it before $ case.

Let us consider the use of patterns in case on example of the rock-paper-scissors game. There are multiple ways of how to write a function, which will return the winner. The following function uses one case with five branches:

(= (rps-winner $x $y)
   (case ($x $y)
     (((Paper Rock) First)
      ((Scissors Paper) First)
      ((Rock Scissors) First)
      (($a $a) Draw)
      ($_ Second))
   )
)
! (rps-winner Paper Scissors) ; Second
! (rps-winner Rock  Scissors) ; First
! (rps-winner Paper Paper   ) ; Draw


Output
[Second]
[First]
[Draw]
One could also write a function, which checks if the first player wins, and use it twice (for ($x $y) and ($y $x)). This could be more scalable for game extensions with additional gestures, and could be more robust to unexpected inputs (although this should be better handled with types). You can try experimenting with different approaches using the sandbox above.

Operations over atoms
Stdlib contains operations to construct and deconstruct atoms as instances of Expression meta-type. Let us first describe these operations.

Deconstructing expressions
car-atom and cdr-atom are fundamental operations that are used to manipulate atoms. They are named after 'car' and 'cdr' operations in Lisp and other similar programming languages.

The car-atom function extracts the first atom of an expression as a tuple.


! (get-type car-atom) ; (-> Expression %Undefined%)
! (car-atom (1 2 3)) ; 1
! (car-atom (Cons X Nil)) ; Cons
! (car-atom (seg (point 1 1) (point 1 4))) ; seg
Output
[(-> Expression %Undefined%)]
[1]
[Cons]
[seg]
The cdr-atom function extracts the tail of an expression, that is, all the atoms of the argument except the first one.


! (get-type cdr-atom) ; (-> Expression %Undefined%)
! (cdr-atom (1 2 3)) ; (2 3)
! (cdr-atom (Cons X Nil)) ; (X Nil)
! (cdr-atom (seg (point 1 1) (point 1 4))) ; ((point 1 1) (point 1 4))
Output
[(-> Expression Expression)]
[(2 3)]
[(X Nil)]
[((point 1 1) (point 1 4))]
Constructing expressions
cons-atom is a function, which constructs an expression using two arguments, the first of which serves as a head and the second serves as a tail.


! (get-type cons-atom) ; (-> Atom Expression Expression)
! (cons-atom 1 (2 3)) ; (1 2 3)
! (cons-atom Cons (X Nil)) ; (Cons X Nil)
! (cons-atom seg ((point 1 1) (point 1 4))) ; (seg (point 1 1) (point 1 4))
Output
[(-> Atom Expression Atom)]
[(1 2 3)]
[(Cons X Nil)]
[(seg (point 1 1) (point 1 4))]
cons-atom reverses the results of car-atom and cdr-atom:


(= (reconstruct $xs)
   (let* (($head (car-atom $xs))
          ($tail (cdr-atom $xs)))
     (cons-atom $head $tail))
)
! (reconstruct (1 2 3)) ; (1 2 3)
! (reconstruct (Cons X Nil)) ; (Cons X Nil)
Output
[(1 2 3)]
[(Cons X Nil)]
Note that we need let in the code above, because cons-atom expects "meta-typed" arguments, which are not reduced. For example, cdr-atom will not be evaluated in the following code:


! (cons-atom 1 (cdr-atom (1 2 3))) ; (1 cdr-atom (1 2 3))
Output
[(1 cdr-atom (1 2 3))]
Let us consider how basic recursive processing of expressions can be implemented:


(: map-expr (-> (-> $t $t) Expression Expression))
(= (map-expr $f $expr)
   (if (== $expr ()) ()
       (let* (($head (car-atom $expr))
              ($tail (cdr-atom $expr))
              ($head-new ($f $head))
              ($tail-new (map-expr $f $tail))
             )
         (cons-atom $head-new $tail-new)
       )
   )
)
! (map-expr not (False True False False))
Output
[(True False True True)]
Comparison with custom data constructors
A typical way to construct lists using custom data structures is to introduce a symbol, which can be used for pattern-matching. Then, extracting heads and tails of lists becomes straightforward, and special functions for this are not need. They can be easily implemented via pattern-matching:


(= (car (Cons $x $xs)) $x)
(= (cdr (Cons $x $xs)) $xs)
! (cdr (Cons 1 (Cons 2 (Cons 3 Nil))))
Output
[(Cons 2 (Cons 3 Nil))]
But one can implement recursive processing without car and cons:


(: map (-> (-> $t $t) Expression Expression))
(= (map $f Nil) Nil)
(= (map $f (Cons $x $xs))
   (Cons ($f $x) (map $f $xs)))
! (map not (Cons False (Cons True (Cons False (Cons False Nil)))))
Output
[(Cons True (Cons False (Cons True (Cons True Nil))))]
Instead of Expression, one would typically use a polymorphic List type (as described another tutorial).

Implementing map with the use of pattern matching over list constructors is much simpler. Why can't it be made with cons-atom? cons-atom, car-atom, cdr-atom work on the very base meta-level as grounded functions. If we introduced explicit constructors for expressions, then we would just move this meta-level further, and the question would arise how expressions with these new constructors are constructed. Apparently, we need to stop somewhere and introduce the very basic operations to construct all other composite expressions. Using explicit data constructors should typically be preferred over resorting to these atom-level operations.

Typical usage
car-atom and cdr-atom are typically used for recursive traversal of an expression. One basic example is creation of lists from tuples. In case of reducible non-nested lists, the code is simple:


(= (to-list $expr)
   (if (== $expr ()) Nil
     (Cons (car-atom $expr)
           (to-list (cdr-atom $expr)))
   )
)
! (to-list (False (True False) False False))
Output
[(Cons False (Cons (True False) (Cons False (Cons False Nil))))]
Parsing a tuple of arbitrary length (if the use of explicit constructors is not convenient) is a good use case for operations with expressions. For example, one may try implementing let* by subsequently processing the tuple of variable-value pairs and applying let.

One more fundamental use case for analyzing expressions is implementation of custom interpretation schemes, if they go beyond the default MeTTa interpretation process and domain specific languages. A separate tutorial will be devoted to this topic. But let us note here that combining car-atom and cdr-atom with get-metatype will be a typical pattern here. Here, we provide a simple example for parsing nested tuples:


(= (to-tree $expr)
   (case (get-metatype $expr)
      ((Expression
         (if (== $expr ()) Nil
             (Cons (to-tree (car-atom $expr))
                   (to-tree (cdr-atom $expr)))
         ))
       ($_ $expr)
      )
   )
)
! (to-tree (False (True False) False False))
Output
[(Cons False (Cons (Cons True (Cons False Nil)) (Cons False (Cons False Nil))))]
Note the difference of the result with to-list. The internal (True False) is also converted to the list now. It happens because the head of the current tuple is also passed to to-tree. For this to work, we need to analyze if the argument is an expression. If it is not, the value is not transformed.

Using MeTTa from Python

Running MeTTa in Python
Introduction
As Python has a broad range of applications, including web development, scientific and numeric computing, and especially AI, ML, and data analysis, its combined use with MeTTa significantly expands the possibilities of building AI systems. Both ways can be of interest:

embedding Python objects into MeTTa for serving as sub-symbolic (and, in particular, neural) components within a symbolic system;
using MeTTa from Python for defining knowledge, rules, functions, and variables which can be referred to in Python programs to create prompt templates for LLMs, logical reasoning, or compositions of multiple AI agents.
We start with the use of MeTTa from Python via high-level API, and then we will proceed to a tighter integration.

Setup
Firstly, you need to have MeTTa’s Python API installed as a Python package. MeTTa itself can be built from source with Python support and installed in the development mode in accordance with the instructions in the github repository. This approach is more involved, but it will yield the latest version with a number of configuration options.

However, for a quick start, hyperon package available via pip under Linux or MacOs (possibly except for newest processors):


pip install hyperon
MeTTa runner class
The main interface class for MeTTa in Python is MeTTa class, which represents a runner built on top of the interpreter to execute MeTTa programs. It can be imported from hyperon package and its instance can be created and used to run MeTTa code directly:


from hyperon import MeTTa
metta = MeTTa()
result = metta.run('''
   (= (foo) boo)
   ! (foo)
   ! (match &self (= ($f) boo) $f)
''')
print(result) # [[boo], [foo]]
Output
[[boo], [foo]]
The result of run is a list of results of all evaluated expressions (following the exclamation mark !). Each of this results is also a list (each containing one element in the example above). These results are not printed to the console by metta.run. They are just returned. Thus, we print them in Python.

Let us note that MeTTa instance preserve their program space after run has finished. Thus, run can be executed multiple times:


from hyperon import MeTTa
metta = MeTTa()
metta.run('''
	(Parent Tom Bob)
	(Parent Pam Bob)
	(Parent Tom Liz)
	(Parent Bob Ann)
''')
print(metta.run('!(match &self (Parent Tom $x) $x)')) # [[Liz, Bob]]
print(metta.run('!(match &self (Parent $x Bob) $x)')) # [[Tom, Pam]]
Output
[[Bob, Liz]]
[[Tom, Pam]]
Parsing MeTTa code
The runner has methods for parsing a program code instead of executing it. Parsing produces MeTTa atoms wrapped into Python objects (so they can be manipulated from Python). Creating a simple expression atom (A B) looks like


atom = metta.parse_single('(A B)')
The parse_single() method parses only the next single token from the text program, thus the following example will give equivalent results


from hyperon import MeTTa
metta = MeTTa()
atom1 = metta.parse_single('(A B)')
atom2 = metta.parse_single('(A B) (C D)')
print(atom1) # (A B)
print(atom2) # (A B)
Output
(A B)
(A B)
The parse_all() method can be used to parse the whole program code given in the string and get the list of atoms


from hyperon import MeTTa
metta = MeTTa()
program = metta.parse_all('(A B) (C D)')
print(program) # [(A B), (C D)]
Output
[(A B), (C D)]
Accessing the program Space
Let us recall that Atomspace (or just Space) is a key component of MeTTa. It is essentially a knowledge representation database (which can be thought of as a metagraph) and the associated MeTTa functions are used for storing and manipulating information.

One can get a reference to the current program Space, which in turn may be accessed directly, wrapped in some way, or passed to the MeTTa interpreter. Having the reference, one can add new atoms into it using the add_atom() method


metta.space().add_atom(atom)
Now let us call the run() method that runs the code from the program string containing a symbolic expression


from hyperon import MeTTa
metta = MeTTa()
atom = metta.parse_single('(A B)')
metta.space().add_atom(atom)
print(metta.run("!(match &self (A $x) $x)")) # [[B]]
Output
[[B]]
The program passed to run contains only one expression !(match &self (A $x) $x). It calls the match function for the pattern (A $x) and returns all matches for the $x variable. The result will be [[B]], which means that add_atom has added (A B) expression extracted from the string by parse_single. The code


atom = metta.parse_single('(A B)')
metta.space().add_atom(atom)
is effectively equivalent to


metta.run('(A B)')
because expressions are not preceded by ! are just added to the program Space.

Please note that


atom = metta.parse_all('(A B)')
is not precisely equivalent to


metta.run('! (A B)')[0]
Although the results can be identical, the expression passed to run will be evaluated and can get reduced:


from hyperon import MeTTa
metta = MeTTa()
print(metta.run('! (A B)')[0])    # [(A B)]
print(metta.run('! (+ 1 2)')[0])  # [3]
print(metta.parse_all('(A B)'))   # [(A B)]
print(metta.parse_all('(+ 1 2)')) # [(+ 1 2)]
Output
[(A B)]
[3]
[(A B)]
[(+ 1 2)]
parse_single or parse_all are more useful, when we want not to add atoms to the program Space, but when we want to get these atoms without reduction and to process them further in Python.

Besides add_atom (and remove_atom as well), Space objects have query method.


metta = MeTTa()
metta.run('''
	(Parent Tom Bob)
	(Parent Pam Bob)
	(Parent Tom Liz)
	(Parent Bob Ann)
''')
pattern = metta.parse_single('(Parent $x Bob)')
print(metta.space().query(pattern)) # [{ $x <- Pam }, { $x <- Tom }]
Output
[ { $x <- Tom },
 { $x <- Pam } ]
In contrast to match in MeTTa itself, query doesn't take the output pattern, but just returns options for variable bindings, which can be useful for further custom processing in Python. It would be useful to have a possibility to define patterns directly in Python instead of parsing them from strings.

MeTTa atoms in Python
Class Atom in Python (see its implementation) is used to wrap all atoms created in the backend of MeTTa into Python objects, so they can be manipulated in Python. An atom of any kind (metatype) can be created as an instance of this class, but classes SymbolAtom, VariableAtom, ExpressionAtom and GroundedAtom together with helper functions are inherited from Atom for convenience.

SymbolAtom
Symbol atoms are intended for representing both procedural and declarative knowledge entities for fully introspective processing. Such symbolic representations can be used and manipulated to infer new knowledge, make decisions, and learn from experience. It's a way of handling and processing abstract and arbitrary information.

The helper function S() is a convenient tool to construct an instance of SymbolAtom Python class. Its only specific method is get_name, since symbols are identified by their names. All instances of Atom has get_metatype method, which returns the atom metatype maintained by the backend.


from hyperon import S, SymbolAtom, Atom
symbol_atom = S('MyAtom')
print(symbol_atom.get_name()) # MyAtom
print(symbol_atom.get_metatype()) # AtomKind.SYMBOL
print(type(symbol_atom)) # SymbolAtom
print(isinstance(symbol_atom, SymbolAtom)) # True
print(isinstance(symbol_atom, Atom)) # True
Output
MyAtom
AtomKind.SYMBOL
<class 'hyperon.atoms.SymbolAtom'>
True
True
Let us note that S('MyAtom') is a direct way to construct a symbol atom without calling the parser as in metta.parse_single('MyAtom'). It allows constructing symbols with the use of arbitrary characters, which can be not accepted by the parser.

VariableAtom
A VariableAtom represents a variable (typically in an expression). It serves as a placeholder that can be matched with, or bound to other Atoms. V() is a convenient method to construct a VariableAtom:


from hyperon import V
var_atom = V('x')
print(var_atom) # $x
print(var_atom.get_name()) # x
print(var_atom.get_metatype()) # AtomKind.VARIABLE
print(type(var_atom)) # VariableAtom
Output
$x
x
AtomKind.VARIABLE
<class 'hyperon.atoms.VariableAtom'>
VariableAtom also has get_name method. Please note that variable names don't include $ prefix in internal representation. It is used in the program code for the parser to distinguish variables and symbols.

ExpressionAtom
An ExpressionAtom is a list of Atoms of any kind, including expressions. It has the get_children() method that returns a list of all children Atoms of an expression. E() is a convenient method to construct expressions, it takes a list of atoms as an input. The example below shows that queries can be constructed in Python and the resulting expressions can be processed in Python as well.


from hyperon import E, S, V, MeTTa

metta = MeTTa()
expr_atom = E(S('Parent'), V('x'), S('Bob'))
print(expr_atom) # (Parent $x Bob)
print(expr_atom.get_metatype()) # AtomKind.EXPR
print(expr_atom.get_children()) # [Parent, $x, Bob]
# Let us use expr_atom in the query
metta = MeTTa()
metta.run('''
	(Parent Tom Bob)
	(Parent Pam Bob)
	(Parent Tom Liz)
	(Parent Bob Ann)
''')
print(metta.space().query(expr_atom)) # [{ $x <- Pam }, { $x <- Tom }]
result = metta.run('! (match &self (Parent $x Bob) (Retrieved $x))')[0]
print(result) # [(Retrieved Tom) (Retrieved Pam)]
# Ignore 'Retrieved' in expressions and print Pam, Tom
for r in result:
	print(r.get_children()[1])
Output
(Parent $x Bob)
AtomKind.EXPR
[Parent, $x, Bob]
[ { $x <- Tom },
 { $x <- Pam } ]
[(Retrieved Tom), (Retrieved Pam)]
Tom
Pam
GroundedAtom
GroundedAtom is a special subtype of Atom that makes a connection between the abstract, symbolically represented knowledge within AtomSpace and the external environment or the behaviors/actions in the outside world. Grounded Atoms often have an associated piece of program code that can be executed to produce specific output or trigger an action.

For example, this could be used to pull in data from external sources into the AtomSpace, to run a PyTorch model, to control an LLM agent, or to perform any other action that the system needs to interact with the external world, or just to perform intensive computations.

Besides the content, which a GroundedAtom wraps, there are three other aspects which can be customized:

the type of GroundedAtom (kept within the Atom itself);
the matching algorithm used by the Atom;
a GroundedAtom can be made executable, and used to apply sub-symbolic operations to other Atoms as arguments.
Let us start with basic usage. G() is a convenient method to construct a GroundedAtom. It can accept any Python object, which has copy method. In the program below, we construct an expression with a custom grounded atom and add it to the program Space. Then, we perform querying to retrieve this atom. GroundedAtom has get_object() method to extract the data wrapped into the atom.


from hyperon import *
metta = MeTTa()
entry = E(S('my-key'), G({'a': 1, 'b': 2}))
metta.space().add_atom(entry)
result = metta.run('! (match &self (my-key $x) $x)')[0][0]
print(type(result)) # GroundedAtom
print(result.get_object()) # {'a': 1, 'b': 2}
Output
<class 'hyperon.atoms.GroundedAtom'>
{'a': 1, 'b': 2}
As the example shows, we can add a custom grounded object to the space, query and get it in MeTTa, and retrieve back to Python.

However, wrapping Python object directly to G() is typically not recommended. Python API for MeTTa implements a generic class GroundedObject with the field content storing a Python object of interest and the copy method. There are two inherited classes, ValueObject and OperationObject with some additional functionality. Methods ValueAtom and OperationAtom is a sugared way to construct G(ValueObject(...)) and G(OperationObject(...)) correspondingly. Thus, it would be preferable to use ValueAtom({'a': 1, 'b': 2}) in the code above, although one would need to write result.get_object().content to access the corresponding Python object (ValueObject has a getter value for content as well, while OperationObject uses op for this).

The GroundedObject constructor takes a content argument (a Python object) to wrap into a grounded atom. It also optionally accepts an id argument to represent the atom and to compare atoms if using the content for this purpose isn't ideal. The ValueObject class provides a getter method value to return the content of the grounded atom.

Arguments of the OperationObject constructor include name, op, and unwrap. name serves as the id for the grounded atom, op (a function) defining the operation is used as the content of the grounded atom, and unwrap (a boolean, optional) indicates whether to unwrap the GroundedAtom content when applying the operation (see more on uwrap on the next page of this tutorial).

While there is a choice whether to use ValueAtom and OperationAtom classes for custom objects or to directly wrap them into G, grounded objects constructed in the MeTTa code are returned as such sugared atoms:


from hyperon import *
metta = MeTTa()
calc = metta.run('! (+ 1 2)')[0][0]
print(type(calc.get_object())) # ValueObject
print(calc.get_object().value) # 3

metta.run('(my-secret-symbol 42)') # add the expression to the space
pattern = E(V('x'), ValueAtom(42))
print(metta.space().query(pattern)) # { $x <- my-secret-symbol }
Output
<class 'hyperon.atoms.ValueObject'>
3
[ { $x <- my-secret-symbol } ]
As can be seen from the example, ValueAtom(42) can be matched against 42 appeared in the MeTTa program (although it is not recommended to use grounded atoms as keys for querying).

It should be noted, however, that stdlib operations in MeTTa are not Python operations. While atoms wrapping objects of such privitive types as Number are automatically converted into Python objects (so one can get Python 3 from calculations !(+ 1 2) in MeTTa), the following code will cause a error, because the grounded operation wrapped by + atom is not a Python operation.


plus = metta.parse_single('+')
plus.get_object()
There is a module called py_ops, which replaces some basic operations with Python operations, so the following code works:


from hyperon import *
metta = MeTTa()
metta.run("! (import! &self py_ops)")
plus = metta.parse_single('+')
print(type(plus.get_object())) # OperationObject
print(plus.get_object().op) # some lambda
print(plus.get_object()) # + as a representation of this operation
print(metta.run('!(* "A" 4)')) # [["AAAA"]]
Output
<class 'hyperon.atoms.OperationObject'>
<function arithm_ops.<locals>.<lambda> at 0x7f125598d9e0>
+
[["AAAA"]]
Apparently, there is a textual representation of grounded atoms, from which atoms themselves are built by the parser. But is it possible to introduce such textual representations for custom grounded atoms, so we could refer to them in the textual program code? The answer is yes. The Python and MeTTa API for this is described on the next page.

Parsing grounded atoms
Tokenizer
The MeTTa interpreter operates with the internal representation of programs in the form of atoms. Atoms can be constructed in the course of parsing or directly using the corresponding API. Let us examine what atoms are constructed by the parser. In the following program, we parse the expression (+ 1 S).


from hyperon import *
metta = MeTTa()
expr1 = metta.parse_single('(+ 1 S)')
expr2 = E(S('+'), S('1'), S('S'))
print('Expr1: ', expr1)
print('Expr2: ', expr2)
print('Equal: ', expr1 == expr2)
for atom in expr1.get_children():
    print(f'type({atom})={type(atom)}')
Output
Expr1:  (+ 1 S)
Expr2:  (+ 1 S)
Equal:  False
type(+)=<class 'hyperon.atoms.GroundedAtom'>
type(1)=<class 'hyperon.atoms.GroundedAtom'>
type(S)=<class 'hyperon.atoms.SymbolAtom'>
The result of parsing differs from the expression (+ 1 S) composed of symbolic atoms. Indeed, the atoms constructed from + and 1 by the parser are grounded atoms - not symbols. At the same time, S('+') is already a symbol atom.

Transformation of the textual representation to grounded atoms is not hard-coded. It is done by the tokenizer on the base of a mapping from tokens in the form of regular expressions to constructors of corresponding grounded atoms.

The initial mapping is provided by the stdlib module, but it can be modified later. In the simple case, tokens are just strings. For example, the tokenizer is informed that if + is encountered in the course of parsing, the following atom should be constructed


OperationAtom('+', lambda a, b: a + b,
              ['Number', 'Number', 'Number'])
Here, ['Number', 'Number', 'Number'] is a sugared way to defined the type (-> Number Number Numer), which should also be represented as an atom.

Regular expressions are needed for such cases as parsing numbers. For example, integers are constructed on the base of the token r"[-+]?\d+", and the constructor needs to get the token itself, so the atom is created by the following function once the token is encountered


lambda token: ValueAtom(int(token), 'Number')
evaluate_atom
Once atoms are created, the interpreter doesn't rely on the tokenizer. Instances of MeTTa class have method evaluate_atom, which is the function accepting the atom to interpret.


from hyperon import *
metta = MeTTa()
expr1 = metta.parse_single('(+ 1 2)')
print(metta.evaluate_atom(expr1))
expr2 = E(OperationAtom('+', lambda a, b: a + b),
          ValueAtom(1), ValueAtom(2))
print(metta.evaluate_atom(expr2))
Output
[3]
[3]
The example above shows that the parsed expression is interpreted in the same ways as the expression atom constructed directly. MeTTa.run simply parses the program code expression-by-expression and puts the resulting atoms in the program space or immediately interprets them when ! precedes the expression. Note that we could get the operation atom for + (which would be correctly typed) via metta.parse_single('+')

Creating new tokens
Access to the tokenizer is provided by the tokenizer() method of the MeTTa class. However, it may not be used directly. MeTTa class has the register_token method, which is intended for registering a new token. It accepts a regular expression and a function, which will be called to construct an atom each time the token is encountered. The constructed atom should not necessarily be a grounded atom, although it is the most typical case.

If the token is a mere string, and creation of different atoms depending on a regular expression is not supposed, register_atom can be used. It accepts a regular expression and an atom, and calls register_token with the given token and with the lambda simply returning the given atom.

The following example illustrates creation of an Atomspace and wrapping it into a GroundedAtom


from hyperon import *

metta = MeTTa()

# Getting a reference to a native GroundingSpace,
# implemented by the MeTTa core library.
grounding_space = GroundingSpaceRef()
grounding_space.add_atom(E(S("A"), S("B")))
space_atom = G(grounding_space)

# Registering a new custom token based on a regular expression.
# The new token can be used in a MeTTa program.
metta.register_atom("&space", space_atom)
print(metta.run("! (match &space (A $x) $x)"))
Output
[[B]]
Parsing and interpretation
Although the interpreter works with the representation of programs in the form of atoms (as was mentioned above), and expressions should be parsed before being interpreted, the tokenizer can be changed in the course of MeTTa script execution. It is essential for the MeTTa module system (described in more detail in another tutorial).

import! is not only loads a module code into a space. It can also modify the tokenizer with tokens declared in the module. This is the reason why a MeTTa is not first entirely converted to atoms and then interpreted, but parsing and interpretation are intervened. Another approach would be to load all the atoms as symbols and resolve them at runtime, so the interpreter would verify if some symbols are grounded in subsymbolic data. This approach would have its benefits, and it might be chosen in the future versions of MeTTa. However, it would imply that introduction of new groundings to symbols has retrospective effect on the previous code.

We have also encountered creation of new tokens inside MeTTa programs with the use of bind! showing that token bindings don't have backward effect. The same is definitely true, when we create tokens using Python API:


from hyperon import *

# A function to be registered
def dup_str(s, n):
    r = ""
    for i in range(n):
        r += s
    return r

metta = MeTTa()
# Create an atom. "dup-str" is its internal name
dup_str_atom = OperationAtom("dup-str", dup_str)

# Interpreter will call this operation atom provided directly
print(metta.evaluate_atom(E(dup_str_atom, ValueAtom("-hello-"), ValueAtom(3))))

# Let us add a function calling `dup-str`
metta.run('''
  (= (test-dup-str) (dup-str "a" 2))
''')

# The parser doesn't know it, so dup-str will not be reduced
print(metta.run('''
 ! (dup-str "-hello-" 3)
 ! (test-dup-str)
'''))

# Now the token is registered. New expression will be reduced.
# However, `(= (test-dup-str) (dup-str "a" 2))` was added
# before `dup-str` token was introduced. Thus, it will still
# remain not reduced.
metta.register_atom("dup-str", dup_str_atom)
print(metta.run('''
! (dup-str "-hello-" 3)
! (test-dup-str)
'''))
Output
["-hello--hello--hello-"]
[[(dup-str "-hello-" 3)], [(dup-str "a" 2)]]
[["-hello--hello--hello-"], [(dup-str "a" 2)]]
Kwargs for OperationAtom
Python supports variable number of arguments in functions. Such functions can be wrapped into grounded atoms as well.


from hyperon import *
def print_all(*args):
    for a in args:
        print(a)
    return [Atoms.UNIT]
metta = MeTTa()
metta.register_atom("print-all", OperationAtom("print-all", print_all))
metta.run('(print-all "Hello" (+ 40 2) "World")')
Output
<empty string>
In cases when the function representing the operation has optional arguments with default values, the Kwargs keyword can be used to pass the keyword parameters. For example, let us define a grounded function find-pos which receives two strings and searches for the position of the second string in the first one. Let the default value for the second string be "a". Additionally, this function has the third parameter which specifies whether the search should start from the left or the right, with the default value being left=True.


from hyperon import *
def find_pos(x:str, y="a", left=True):
    if left:
        return x.find(y)
    pos = x[-1:].find(y)
    return len(x) - 1 - pos if pos >= 0 else pos
metta = MeTTa()
metta.register_atom("find-pos", OperationAtom("find-pos", find_pos))
print(metta.run('''
 ! (find-pos "alpha") ; 0
 ! (find-pos (Kwargs (x "alpha") (left False))) ; 4
 ! (find-pos (Kwargs (x "alpha") (y "c") (left False))) ; -1
'''))
Output
[[0], [4], [-1]]
Hence, to set argument values using Kwargs, one needs to pass pairs of argument names and values.

Unwrapping Python objects from atoms
Above, we have introduced a summation operation as OperationAtom('+', lambda a, b: a + b),where a and b are Python numbers instead of atoms. a + b is also not an atom. Creating of operation atoms getting Python objects is convenient, because it eliminates the necessity to retrieve values from grounded atoms and wrap the result of the operation back to the grounded atom. However, sometimes it is needed to write functions that operate with atoms themselves, and these atoms may not be grounded atoms wrapping Python objects.

Unwrapping Python values from input atoms and wrapping the result back into a grounded atom is the default behavior of OperationAtom, which is controlled by the parameter unwrap. Let us consider an example of implementing + while setting this parameter to False.


def plus(atom1, atom2):
    from hyperon import ValueAtom
    sum = atom1.get_object().value + atom2.get_object().value
    return [ValueAtom(sum, 'Number')]

from hyperon import OperationAtom, MeTTa
plus_atom = OperationAtom("plus", plus,
    ['Number', 'Number', 'Number'], unwrap=False)
metta = MeTTa()
metta.register_atom("plus", plus_atom)
print(metta.run('! (plus 3 5)'))
Output
[[8]]
When unwrap is False, a function should be aware of the hyperon module, which can be inconvenient for purely Python functions. Thus, this setting is desirable for functions processing or creating atoms themselves. For example, bind! takes an atom to be bound to a token. parse takes a string and return an atom of any metatype constructed by parsing this string. One can imagine different custom operations, which accept and return atoms. Say, if a crossover operation in genetic algorithms would be implemented as a grounded operation, it would accept two atoms (typically, expressions), traverse them to find crossover points, and construct a child expression.

Embedding Python objects into MeTTa
py-atom
Introducing tokens for grounded atoms allows for both convenient syntax and direct representation of expressions with corresponding grounded atoms in a Space. However, wrapping all functions of rich Python libraries can be not always desirable. There is a way to invoke Python objects such as functions, classes, methods or other statements from MeTTa without additional Python code wrapping these objects into atoms.

py-atom allows obtaining a grounded atom for a Python object imported from a given module or submodule. Let us consider usage of numpy as an example, which should be installed. For instance, the absolute value of a number in MeTTa can be calculated by employing the absolute function from the numpy library:


! ((py-atom numpy.absolute) -5) ; 5
Output
[np.int64(5)]
Here, py-atom imports numpy library and returns an atom associated with the numpy.absolute function.

It is possible to designate types for the grounded atom in py-atom. For convenience, one can associate the result of py-atom with a token using bind!:


! (import! &self py_ops)
! (bind! abs (py-atom numpy.absolute))
! (+ (abs -5) 10) ; np.int64(15)
Output
[()]
[()]
[np.int64(15)]
We specify here that the constructed grounded operation can accept an argument of type Number and its result will be of Number type.

When (abs -5) is executed, it triggers a call to absolute(-5). It can be seen that the results of executing Python objects imported via py-atom can then be directly utilized in other MeTTa expressions.

py-atom can actually execute some Python code, which shouldn't be a statement like x = 42, but should be an expression, which evaluation produces a Python object. In the following example, (py-atom "[1, 2, 3]") produces a Python list, which then passed to numpy.array.


! (bind! np-array (py-atom numpy.array))
! (np-array (py-atom "[1, 2, 3]")) ; array([1, 2, 3])
Output
[()]
[array([1, 2, 3])]
py-atom can be applied to functions accepting keyword arguments. Constructed grounded atoms will also support Kwargs (mentioned earlier), which allows for passing only the required arguments to the function while skipping arguments with default values. For example, there is numpy.arange in NumPy, which returns evenly spaced values within a given interval. numpy.arange can be called with a varying number of positional arguments:


! (bind! np-arange (py-atom numpy.arange)) ; ()
! (np-arange 4) ; array([0, 1, 2, 3])
! (np-arange (Kwargs (step 2) (stop 8))) ; array([0, 2, 4, 6])
! (np-arange (Kwargs (start 2) (stop 10) (step 3))) ; array([2, 5, 8])
Output
[()]
[array([0, 1, 2, 3])]
[array([0, 2, 4, 6])]
[array([2, 5, 8])]
py-dot
What if we wish to call functions from a submodule, say numpy.random? Accessing these functions via something like (py-atom numpy.random.randint) will work. However, it would be more efficient to get numpy.random itself as a Python object and access other objects in it. py-dot is introduced to carry out this operation.


! (bind! np-rnd (py-atom numpy.random))
! ((py-dot np-rnd randint) 25)
Output
[()]
[22]
In this case py-dot operates with two arguments: it takes the first argument, which is the grounded atom wrapping a Python object, and then searches for the value of an attribute within that object based on the name provided in the second argument.

This second argument can also contain objects in submodules. In the following example, we wrap numpy in the grounded atom:


! (bind! np (py-atom numpy))
! ((py-dot np abs) -5)
! ((py-dot np random.randint) -25 0)
! ((py-dot np abs) ((py-dot np random.randint) -25 0))
Output
[()]
[np.int64(5)]
[-15]
[np.int64(25)]
Here, when (py-dot np random.randint) is executed, it takes numpy object and searches for random in it and then for randint in random. The overall result is the grounded operation wrapping numpy.random.randint, which is then applied to some argument. Similar to py-atom, py-dot also permits the designation of types for the function, and supports Kwargs for arguments specification.

Binding np to (py-atom numpy) and accessing functions in it via (py-dot np abs) looks not more convenient than just using (py-atom numpy.abs), but is slightly more efficient if numpy.abs is accessed multiple times.

py-dot works for any Python object - not only modules:


! ((py-dot "Hello World" swapcase)) ; "hELLO wORLD"
Output
["hELLO wORLD"]
Notice the additional brackets to call swapcase. The equivalent Python code is "Hello World".swapcase(), which also contains (). One more pair of brackets in MeTTa is needed, because py-dot is also a function.

Let us consider another example.


! ((py-dot (py-atom "{5: \'f\', 6: \'b\'}") get) 5)
Output
["f"]
Here, a dictionary {5: 'f', 6: 'b'} is created by py-atom, and then the value corresponding to the key 5 is retrieved from this dictionary using get accessed via py-dot.

py-list, py-tuple, py-dict
While it is possible to create Python lists and dictionaries using code evaluation by py-atom, it can be desirable to construct these data structures by combining atoms in MeTTa.

In this context, since passing dictionaries, lists or tuples as arguments to functions in Python is very common, such dedicated functions as py-dict, py-list and py-tuple were introduced.


! ((py-atom max) (py-list (-5 5 -3 10 8))) ; 10
! ((py-atom numpy.inner)
     (py-list (1 2)) (py-list (3 4))) ; 1 * 3 + 2 * 4 = 11
Output
[10]
[np.int64(11)]
In this example, py-list generates three Python lists: [-5, 5, -3, 10, 8] , [1,2] and [3,4], which are passed to max and numpy.inner.

Of course, one can use py-dict, py-list, and py-tuple independently - not just as function arguments:


! (py-dict (("a" "b") ("b" "c"))) ; creates a dict {"a":"b", "b":"c"}
! (py-tuple (1 5)) ; creates a tuple (1, 5)
! (py-list (1 (2 (3 "3")))) ; creates a nested list [1, [2, [3, '3']]]
Output
[{'a': 'b', 'b': 'c'}]
[(1, 5)]
[[1, [2, [3, '3']]]]


Libraries
MeTTa-Motto
MeTTa-Motto is a library that allows combining the capabilities of LLMs (Large Language Models) and MeTTa. MeTTa-Motto allows calling LLMs from MeTTa scripts, which enables prompt composition and chaining of calls to LLMs in MeTTa based on symbolic knowledge and reasoning.

Simple queries to LLMs
To make simple queries to an LLM using the MeTTa-Motto library, the following commands can be used:


!((anthropic-agent) (user "What is a black hole?"))

!((chat-gpt-agent)
      (user "What is a black hole?"))
chat-gpt-agent and anthropic-agent are the agents used to make requests to the ChatGPT and Claude model respectively. Currently, MeTTa-Motto supports the following LLMs:

ChatGPT (by OpenAI)
Claude (by Anthropic)
but more LLMs can be added if needed, and one can also use other LLMs via LangChain integration (see below).

Additionally, it is possible to specify the version of ChatGPT or Claude, such as


(chat-gpt-agent "gpt-3.5-turbo")
(anthropic-agent "claude-3-opus-20240229")
In the example above, the agent may not be specified: !(llm (user "What is a black hole?")). In this case, the default agent (currently, chat-gpt) will be used. The messages which we send to agents as parameters have the form (ROLE "Text of the Message"). There are 3 roles for messages: user, assistant and system.

llm is a method defined in MeTTa-Motto, which passes messages to the specified agent and returns their results to MeTTa. For convenience, the keyword llm has been omitted in scripts starting from MeTTa-Motto version 0.0.7. The previous syntax:


!(llm (Agent (chat-gpt))
      (user "What is a black hole?")) ;
is now automatically included in the code for the given agent.

We've also included the open-router-agent to use the OpenRouter API for obtaining responses from LLMs:


!(import! &self motto)
!((open-router-agent) (user "Who was the 22nd President of France?"))
!((open-router-agent "openai/gpt-3.5-turbo" True) (user "Who was the 22nd President of France?"))
this agent allows to specify the model type, the second call has one more additional parameter True which means that the response should be a stream (Streaming)

As a demonstration, instead of calling LLM agents, we will use the echo-agent. This agent returns the message sent to it, including the role on whose behalf the message was sent


!(import! &self motto) ; ()
!((echo-agent)
      (user "The agent will return this text along with a role: user"))
      ; "user The agent will return this text along with a role: user"
Output
[()]
["user The agent will return this text along with a role: user"]
MeTTa agents
Also, as an Agent, we can specify the path to a file with a MeTTa script, which typically has a .msa (MeTTa Script Agent) extension. This script can contain any commands (expressions) in MeTTa, and may not necessarily include queries to LLMs in it, but it is supposed to run in a certain context.

For example, let us assume, there is a file named some_agent.msa containing the following code:


( = (response)
   (if (== (messages) (user "Hello world."))
       "Hi there"
       "Bye"))
(response) is used to indicate that this is the output of the agent. The some_agent.msa can be used in another script in the following manner:


!(import! &self motto)
!((metta-script-agent "some_agent.msa")
      (user "Hello world.")) ; Hi there
or in the following manner:


!(import! &self motto)
!((metta-agent "some_agent.msa")
      (user "Hello world.")) ; Hi there
For a MeTTa agent, the new atom (= (messages) (user "Hello world.")) will be added to the MeTTa space, where the agent will load some_agent.msa. This allows (messages) to be used within some_agent.msa. Typically, .msa agents are more complex and utilize LLM responses during processing. A metta-agent executes the code in some_agent.msa upon creation, and only runs the (response) function when the __call__ method is executed. In contrast, a metta-script-agent executes the code in some_agent.msa whenever the __call__ method is invoked. This is not the only difference between the two agents. In a metta-agent, there is a field that stores an instance of the MeTTa class, which is used to execute MeTTa code. As a result, all states calculated during the execution of the .msa script will remain in memory (MeTTa space) while the script in which the MeTTa agent was created is running. For metta-script-agent an instance of the MeTTa class is created each time when the __call__ method is executed.

Functional calls
Suppose we have a function that returns the current weather for a location passed as a parameter to this function. We want to ask about the weather in natural language, e.g. "What is the weather in New York today?", and receive information about the weather in conversational format. For such cases one can describe functions and have the LLM model intelligently select and output a JSON object containing the arguments needed to call one or more functions.

The latest OpenAI and Anthropic models have been trained to both detect when a function should to be called (depending on the input) and to respond with JSON that adheres to the function signature more closely. We can describe such functions in MeTTa-Motto too. For example, for the get_current_weather function, we should first describe it within doc section and define the function behavior:


!(import! &self motto)
(= (doc get_current_weather)
   (Doc
     (description "Get the current weather for the city")
     (parameters
       (location "the city: " ("Tokyo" "New York" "London"))
     )
   )
)
(= (get_current_weather ($arg) $msgs)
   (if (contains-str $arg "Tokyo")
       "The temperature in Tokyo is 75 Fahrenheit"
       (if (contains-str $arg "New York")
           "The temperature in New York is 80 Fahrenheit"
           (concat-str (concat-str "The temperature in " $arg)
                       " is 70 Fahrenheit")
    )
  )
)
!((echo-agent)
   (user "Get the current weather for the city: London") 
   (Function get_current_weather) ; The temperature in London is 70 Fahrenheit.
)
Output
[()]
["\"The temperature in London\" is 70 Fahrenheit"]
The parameters section describes the arguments of the function that should be retrieved from the user's message. The parameters can have the following properties: name, type, description and an enum with possible values.

The type property has a specific purpose. It can be provided in the form ((: parameter Atom) "Parameter description") indicating that this parameter should be converted from the Python string to a MeTTa expression before passing to the function.

In our example, concat-str (concatenates two strings) and contains-str (which checks if the first string contains the second string) are grounded functions defined in MeTTa-Motto. echo-agent is used for the demo purpose, but in real applications it will be any agent that supports functional calls. When a functional call is used with echo-agent, arguments can be extracted from the user's message only if the message includes the function description and the parameter description concatenated with a possible value of the parameter (for example: "the city: " + London). This example is useful only for testing and demonstration purposes.

Streaming
Some LLMs has API which allows streaming responses back to a client, enabling partial results for specific requests. metta-motto supports streaming, but currently only for the chat-gpt-agent. By setting the second parameter of the chat-gpt-agent to True, the response of chat-gpt-agent will be an atom that contains a Stream object:


!((chat-gpt-agent "gpt-3.5-turbo" True) (user "How many planets are in the solar system?"))
Scripts
It is convenient to store lengthy prompts and their templates for LLMs in separate files. For this reason, one can specify the path to such a file as a parameter along with agent. While these files are also MeTTa files and can contain arbitrary computations, they are evaluated in a different context and are recommended to have .mps (MeTTa Prompt Script) extension. Basically, each such file is loaded as a MeTTa script to a space, which should contain expressions reduced to the parameters of the llm method. For example, some_template.mps file containing:


(system ("Answer the user's questions if he asks about art, music, books, for other cases say: I can't answer your question"))
can be utilized from another .metta file:


!(import! &self motto)
!((chat-gpt-agent) (Script some_template.mps)
  (user "What is the name of Claude Monet's most famous painting?"))
!((chat-gpt-agent) (Script some_template.mps)
  (user "Which city is the capital of the USA?"))
The following result will be obtained:


"Claude Monet's most famous painting is called "Impression, Sunrise."”
"I can't answer your question."
Notice that the parameters specified in the mps-file are combined with the parameters specified directly. This allows separating reusable parts of prompts and utilizing them in different contexts in a composable way. In particular, if one supposes to try different LLMs with the same prompts, Agent should not be mentioned in the .mps file.

Since prompt templates are just spaces treated as parameters to llm, they can be created and filled in directly, but this is rarely needed.


!(import! &self motto)
!(bind! &space (new-space))
!(add-atom &space (user "Table"))
!(add-atom &space (user "Window"))
!((echo-agent) (Script &space)) ; "user Table user Window"
Output
[()]
[()]
[()]
[()]
["user Table\nuser Window"]
We are using echo-agent here. The result will be a concatenation of all the provided messages.

dialog-agent
To store dialogue history during interaction with LLMs, we include a special dialogue agent. Let us consider an example. We will use the dialog-agent agent for this purpose. Since the agent will be used multiple times, let us create a binding for it:


!(bind! &chat (dialog-agent dialog.msa)))
The dialog-agent agent stores the dialogue history in a special array named history. With each new message, the history is updated. The history array can be accessed from the MeTTa script (in our example, from dialog.msa) via the (history) function.

The file dialog.msa contains the following lines.


(= (context)
   (system "You are an AI assistant.
           Please, respond correspondingly."))
(= (response)
   (llm (Messages (context) (history) (messages))))
And the dialogue can be executed:


!(&chat (user "Hello! My name is John."))
!(&chat (user "What do you know about the Big Bang Theory?"))
!(&chat (user "Do you know my name?")) ; "Yes, you mentioned earlier that your name is John. Is there anything specific you would like to know or discuss?"
After the execution of the following line:


!((dialog-agent dialog.msa) (user "Hello "))
the new atom


= (history) (Messages (user "Hello!") (assistant "Greetings, Frodo Baggins! It is a pleasure to see you. How may I be of assistance to you today?"))
will be added to the MeTTa space, created to execute dialog.msa.

dialog-agent inherits from metta-agent, this means that all states calculated during the execution of the .msa script will remain in memory (MeTTa space) while the script in which the MeTTa agent was created is running.

Retrieval Agent
Sometimes we may require passing information from various documents as parts of prompts for LLMs. However, these documents may also contain irrelevant data not pertinent to our objectives. In such cases, we can use a retrieval agent. When defining this agent, it is necessary to specify the document location or a path to one document, the chunk length for embedding creation, the desired number of chunks for the agent to return, and a designated path for storing the dataset:


!(bind! &retrieval (retrieval-agent "text_for_retrieval.txt" 200 1 "data"))
Here, text_for_retrieval.txt is the document that will be searched according to the user's request, the chunks size is equal to 200, and number of the closest chunks to return is 2. This agent computes embeddings for the provided texts and stores them in a dedicated database. In our case, we use ChromaDB, an open-source vector database. When the retrieval agent is invoked for a particular sentence, it first generates embeddings for the sentence and subsequently returns the closest chunks based on cosine distance metrics. For example, the text contains information about a scientist named John, then we can ask:


(&retrieval (user "What is John working on?"))
Here is the usage example of a retrieval agent with ChatGPT:


!(let $question "What is John working on?"
    ((chat-gpt-agent "gpt-3.5-turbo")
         (Messages
           (system
             ("Taking this information into account, answer the user question"
             (&retrieval (user $question)))
           )
           (user $question)
         )
     )
)
The retrieval agent can search not only within a single document but also across an entire folder if specified. In the following example, ./data/texts_for_retrieval is the path to the folder where additional information can be searched.


!(bind! &retrieval (retrieval-agent "./data/texts_for_retrieval" 200 1 "data"))
!(&retrieval_agent
      (user "Who made significant advancements in the fields of electromagnetism?"))
In this case, you can also specify the required document during the agent call using the special Kwargs keyword:


!((&retrieval (Kwargs (doc_name "story1.txt")))
      (user  "Who made significant advancements in the fields of electromagnetism?"))
LangChain Agents
As mentioned in this tutorial, by using py-atom and py-dot, you can invoke from MeTTa such Python objects as functions, classes, methods, or other statements. Taking this possibility into account, we have created agents in MeTTa-Motto that allow using LangChain components. LangChain is a Python framework for developing applications powered by large language models (LLMs). LangChain supports many different language models. For example, the following code uses GPT to translate text from English to French:


from langchain_openai import ChatOpenAI

llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)
messages = [
    ("system", "You are a helpful assistant that translates English to French."),
    ("human", "Translate this sentence from English to French: I love programming."),
]
llm.invoke(messages)
The implementation of the code, provided above, in MeTTa-Motto looks like this:


!(import! &self motto)
(bind! &chat
  (langchain-agent
    ((py-atom langchain_openai.ChatOpenAI)
     (Kwargs (model "gpt-3.5-turbo") (temperature 0)))
    motto/langchain_agents/langchain_agent.msa))
!(&chat
      (system "You are a helpful assistant that translates English to French.")
      (user "Translate this sentence from English to French: I love programming."))
The grounded function langchain-agent has two parameters. The first is a chat model (in this case, langchain_openai.ChatOpenAI), which should be an instance of LangChain "Runnables" with an invoke method. The second parameter is the path to the file used to call the invoke method for the given chat model.

File motto/langchain_agents/langchain_agent.msa is a part of MeTTa-Motto library and contains the following lines:


(py-dot ((py-dot (langchain-model) invoke) &list) content)
The &list is used to store the entire message history. The grounded atom langchain-model is automatically initialized with the chat model passed to langchain-agent:


(= (langchain-model)
   ((py-atom langchain_openai.ChatOpenAI)
      (Kwargs (model "gpt-3.5-turbo") (temperature 0)))
),
The langchain-agent can be used in the same situations as the chat-gpt-agent or dialog-agent agents.

These examples add not too much for what can be done without LangChain agents. However, if one wants to use LLMs not directly supported by MeTTa-Motto or to use some other components of LangChain together with knowledge representation and symbolic processing capabilities provided by MeTTa, then calling LangChain functions from MeTTa can be very useful. LangChain offers a variety of useful tools. These tools serve as interfaces that an agent, chain, or LLM can use to interact with the world. We can use these tools directly from MeTTa. For example, the following script demonstrates the use of a tool designed to query arXiv, an open-access archive with 2 million scholarly articles across various scientific fields:


!(bind! &arxiv_tool ((py-atom langchain_community.tools.arxiv.tool.ArxivQueryRun)))
!((py-dot &arxiv_tool  invoke) "What's the paper 1605.08386 about?") ;Published: 2011-02-18 Title: Quantum Anticipation Explorer ...
This example demonstrates how to use the tool individually. The tool can also be used as part of an agent. For this purpose, there is langchain_openai_tools_agent.msa in MeTTa-Motto, which utilizes langchain.agents.AgentExecutor to execute LLM agents with the use of LangChain tools:


!(import! &self motto)
!(import! &self motto:langchain_agents:langchain_states)
!(bind! &lst (py-list ()))
!((py-dot &lst append) ((py-atom langchain_google_community.GoogleSearchRun)
    (Kwargs (api_wrapper ((py-atom   langchain_google_community.GoogleSearchAPIWrapper))))))
!(set-langchain-agent-executor  &lst)
!((metta-script-agent "motto/langchain_agents/langchain_openai_tools_agent.msa")(user  "What is the name of the airport in Cali, Colombia?")) ;"The name of the airport in Cali, Colombia is Alfonso Bonilla Aragón International Airport."
The Google search tool is used here to get the answer to the user's question. The script includes the import of the langchain_states.metta file, which contains helper functions to create and store prompts, construct langchain.agents.create_tool_calling_agent, and set parameters for langchain.agents.AgentExecutor.

Advantages of MeTTa-Motto
Using MeTTa-Motto, we can process user messages with LLMs to create new knowledge bases or extend existing ones. These knowledge bases can be further processed using MeTTa expressions and then utilized in MeTTa-Motto to solve various tasks. For example, let's consider an agent defined in the file named some_agent.msa:


(= (response)
    (_eval
        ((chat-gpt-agent)
           (system "Represent natural language statements as expressions in Scheme.
               We should get triples from statements, describing some relations between items.
               Relation of location  should be  represented with 'location' property.
               Relation of  graduated from (or studies)  should be presented as 'educated_at' property.
               For example, the sentence 'New York City is  located at the southern tip of New York State' should be transformed to
               (\"New York City\" location \"New York State\").
               'Lisbon is in Portugal' should be transformed to (\"Lisbon\" location \"Portugal\"). 
               Return cities, countries, states and universities in quotes.
               The sentence  'Ann graduated from the University of Oxford' should be transformed to (Ann educated_at \"Oxford\")
               The sentence 'John is studying mathematics at MIT' should be transformed to (John educated_at \"MIT\")
               For questions about place of study we use function study_location,  for example:
               The sentence 'Is John studying in the USA?' should be transformed to (study_location John \"USA\")
               The sentence 'Did Alan graduate from the University of USA?' should be transformed to (study_location Alan \"USA\")
               The sentence 'Did Mary study in the USA?' should be transformed to (= (study_location Mary \"USA\"))
               Return result without quotes."
           )
           (messages)
        )
    )
)
This agent converts sentences containing location or education-related information into triples, such as (Ann educated_at "Oxford") or ("New York City" location "New York State"). If someone asks about the city or country where the education was received, it converts the question into a MeTTa function. For example: Did Mary study in the USA? will be converted to (= (study_location Mary "USA"). Let's define two functions: is-located, which checks if $x is located in $y, and study_location, which checks if $x studied at a place that is located in $y.


(= (is-located $x $y)
   (case (match &self ($x location $z) $z)
       (
           (Empty False)
           ($z (if  (== $z  $y) True (is-located $z $y) ))
       )
   )
)

(= (study_location $x $y)
   (case (match &self ($x educated_at $z) $z)
       (
           (Empty False)
           ($z (if  (== $z  $y) True (is-located $z $y) ))
       )
   )
)
Then, using the some_agent.msa, we can add certain relations to the meta space based on the provided facts in natural language, and verify certain facts about the place of study.


!(import! &self motto)
(Fact "Harvard is located in Massachusetts state")
(Fact "Massachusetts state is located in United States")
(Fact "Ann graduated from Harvard.")

!(match &self (Fact $fact)
  (let $expr ((metta-script-agent "some_agent.msa") (user $fact))
       (add-atom &self $expr))
 )

!(get-atoms &self)
!((metta-script-agent "some_agent.msa") (user "Did Ann study in the United States?")) ;True
This is a straightforward example demonstrating the potential of Metta-Motto to integrate MeTTa functionality with the capabilities of LLMs.

Running Metta-motto in Python
It is possible to call MeTTa-Motto agents directly from python code:


from motto.agents import  MettaAgent
agent = MettaAgent(code = '''
    (= (response) ((echo-agent) (messages)))
    ''')
print(agent('(user "Hello")').content)
Output
["user Hello"]
In this example, an instance of MettaAgent is created using the code argument, which contains a script that defines the agent's behavior. Alternatively, the agent can be initialized with the path argument instead of code. The path should point to a .mps file containing the script to be executed to get a response from the agent. Similarly, we can use DialogAgent, which inherits all methods of MettaAgent and additionally stores dialogue history. This is the dialog-agent described above. It is possible to pass additional information, and the method call is executed for either MettaAgent or DialogAgent.

For example, let's say the file some_agent.msa contains a script:


(= (respond)
   ((chat-gpt-agent (model_name) (is_stream) True) (Messages (history) (system (system_msg)) (media (media_msg)) (messages)))
)
(= (response) (respond))
here (system_msg) and (media_msg) should be passed to agent during execution.


from motto.agents import  MettaAgent
agent = MettaAgent()
v = agent('(user "What is a black hole?")',
          additional_info=[("system_msg", long, 'String'),
                           ("model_name", "gpt-4o", 'String'),
                           ("is_stream", True, 'Bool'), ""]).content
stream = v[0].get_object().content
for chunk in stream:
    print(chunk.choices[0].delta.content)
This script sends a request to the ChatGPT model gpt-4o. Since is_stream is set to True, the response is returned incrementally in chunks through an event stream. In Python, you can iterate over these events using a for loop.

Backend
Minimal MeTTa
Minimal MeTTa is a basic set of instructions, which are necessary and sufficient to implement the MeTTa interpreter. The interpreter chains the equality queries and calls to grounded functions controlling this process depending on the current evaluation context and results including exceptions (errors), empty or non-reducible results. Thus, the main instruction in Minimal MeTTa is eval, which performs one step of evaluation, and which should be applied and chained explicitly. Any atom, which is not a Minimal MeTTa instruction (and not wrapped into such the instruction) will be evaluated to itself.

Minimal MeTTa instructions are available from MeTTa. However, their results can be different, because they will be processed by the MeTTa interpreter further. In order to work with pure Minimal MeTTa, one can use special pragma. If it is activated, the interpreter will not be used at all, and all expressions in the code will be evaluated without automatic chaining or additional processing. Consider the following example:


!(pragma! interpreter bare-minimal)
(= (foo) (bar))
(= (bar) a)
!(foo) ; (foo)
!(eval (foo)) ; (bar)
Output
[()]
[(foo)]
[(bar)]
(foo) is not reduced, because foo is not a Minimal MeTTa instruction, while (eval (foo)) is reduced, but only to (bar), which is not automatically reduced further. Let us consider the basic Minimal MeTTa instructions.

Basic operations: chain, eval, unify
eval
(eval ARG) searches for the pattern (= ARG $body) in the current space and returns $body unified with the corresponding atom in the space if this equality pattern was matched or NotReducible symbol otherwise. Consider the following example


!(pragma! interpreter bare-minimal) ; ()
(= (foo) (bar))
(= (bar) a)
!(eval (foo)) ; (bar)
!(eval (bar)) ; a
!(baz) ; (baz)
!(eval (baz)) ; NotReducible
Output
[()]
[(bar)]
[a]
[(baz)]
[NotReducible]
(eval (foo)) is reduced to (bar) (but not to a), because (= (foo) $body) matches against (= (foo) (bar)) with $body bound to (bar), while (eval (bar)) is reduced to a. In turn, (eval (baz)) returns NotReducible symbol.

It should be noted that in MeTTa the type of eval is (-> Atom Atom), so its result will not be evaluated further, but such special results as NotReducible will still be processed. Without bare-minimal, we'll get


(= (foo) (bar))
(= (bar) a)
!(baz) ; (baz)
!(eval (foo)) ; (bar)
!(eval (baz)) ; (eval (baz))
Output
[(baz)]
[(bar)]
[(eval (baz))]
(eval (baz)) in MeTTa remains itself, because it is eval that returns NotReducible, so the interpreter keeps the whole expression unreduced. Let us also emphasize that types are processed by the MeTTa interpreter (and could be processed in a different way), while the Minimal MeTTa instructions do not consider them.

It can be confusing at first that (eval (baz)) produces different results in MeTTa and Minimal MeTTa, while (baz) remains itself in both cases. The latter has more complex reasons. (baz) is simply not evaluated in Minimal MeTTa, but the MeTTa interpreter tries to evaluate it (secretly calling eval), receives NotReducible, and returns (baz), because it is (baz) that had no reduction rules (not (eval (baz)) as in the previous example).

There are also other conditions and processing steps, which MeTTa interpreter is doing. Consider the following code:


(= A AA)
! A ; A
!(eval A) ; AA
Output
[A]
[AA]
The MeTTa interpreter applies eval only to expressions, which might be function applications. However, if one explicitly executes eval on a pure symbol, the equality query will also be constructed. There could be other choices, when to execute eval and how to deal with its results. Minimal MeTTa allows implementing different versions of the interpreter. Using Minimal MeTTa instructions from MeTTa can also be used to tweak the interpretation process. However, the fact should be taken into account that they will still be called not directly, but from the interpreter code.

We have covered only a part of eval functionality so far. If the argument is an expression, which first element is a grounded function, then eval calls this function and returns its result. If the result is a grounded error, it is converted as the following:

ExecError::Runtime -> (Error ...)
ExecError::NoReduce -> NotReducible
ExecError::IncorrectArgument -> NotReducible
Let us note that even though bare-minimal turns the MeTTa interpreter off, Minimal MeTTa instructions are still called within its environment, so grounded functions from stdlib are available. Consider the following examples.


!(pragma! interpreter bare-minimal) ; ()
(= (foo) (bar))
(= (bar) a)
!(eval (match &self (= (foo) $x) $x)) ; (bar) 
!(eval (match &self (not-exist $x) $x)) ; Empty
!(eval (+ 1 2)) ; 3
!(eval (+ 1 "a")) ; NotReducible
!(eval (pow-math 2 200000000000000)) ; (Error (pow-math 2 200000000000000) power argument is too big, try using float value)
Output
[()]
[(bar)]
[Empty]
[3]
[NotReducible]
[(Error (pow-math 2 200000000000000) power argument is too big, try using float value)]
match is a grounded function, which can be executed via eval. If matching fails, the result is Empty in Minimal MeTTa. + or any other available grounded function can also be executed via eval. If the argument of a grounded function is not suitable, it will cause an error, which will be converted to NotReducible like in case of (+ 1 "a"). Other errors will be converted to an Error-expression.

It should be noted that eval doesn't process expressions recursively. If the top-level function is applicable to its arguments in their non-reduced form, then, it will be applied before the arguments reduction. Otherwise, the result will be NotReducible.

Consider the following example.


!(pragma! interpreter bare-minimal) ; ()
(= (foo $x) ($x $x))
(= (bar $x $y) ($y $x))
!(eval (bar (foo A) (foo B))) ; ((foo B) (foo A))
Output
[()]
[((foo B) (foo A))]
The result of eval is ((foo B) (foo A)) meaning that bar was successfully applied. Now, consider the following example


!(pragma! interpreter bare-minimal) ; ()
(= (foo OK) OK!!!)
(= (bar) OK)
!(eval (foo (bar))) ; NotReducible
!(eval ((bar))) ; NotReducible
!(eval (+ (+ 1 2) 3)) ; NotReducible
Output
[()]
[NotReducible]
[NotReducible]
[NotReducible]
In all cases, there is no immediate way to evaluate the top-level function, even in the case of ((bar)) expression, which also requires peeking one level deeper into it. Thus, eval is a very basic instruction, and a lot of work is performed by the interpreter. Resorting to eval enables low-level control of the evaluation process, but a lot of functionality should be implemented on top of it manually.

unify
(unify ARG1 ARG2 UNIFIED NOT-UNIFIED) tries to unify ARG1 and ARG2 atoms (any of which can contain variables) and returns UNIFIED (which typically but not necesserily contains variables from ARG1 and/or ARG2) if unification is successful and returns NOT-UNIFIED otherwise.

The basic usage is as following:


!(pragma! interpreter bare-minimal) ; ()
!(unify (a $b) ($a b) ($a $b) fail) ; (a b)
!(unify (a $b) (b a) ok fail) ; fail
Output
[()]
[(a b)]
[fail]
Wrapping unify into eval is not necessary even if bare-minimal is on, because it is a basic Minimal MeTTa instruction itself.

Since spaces implement custom matching, unify can accept them as one of its arguments. Thus, unify can be used instead of match, but with branching depending on the success of unification:


(friend Bob Alice)
!(unify &self (friend $who Alice) $who no-friends) ; Bob
!(unify &self (friend Pol $who) $who no-friends) ; no-friends
Output
[Bob]
[no-friends]
The latter can be achieved with match and case catching Empty, but in a less efficient way.

The code above works identically with and without bare-minimal. However, unify has %Undefined% return type in MeTTa, so its result will be evaluated further by the interpreter.

chain
eval performs only one step of evaluation in Minimal MeTTa, and it is insufficient to perform chained evaluation of custom functions. For example, the following code returns (bar).


!(pragma! interpreter bare-minimal) ; ()
(= (foo) (bar))
(= (bar) a)
!(eval (eval (foo))) ; (bar)
Output
[()]
[(bar)]
Why (bar) instead of (eval (bar)) or a? Minimal MeTTa executes the outermost instruction. This is eval, which evaluates its argument. Since this argument is a grounded function call (inner eval), outer eval calls inner eval and it returns (bar).

It should be underlined that the result of eval will not be evaluated by Minimal MeTTa even if it is a Minimal MeTTa instruction. There is no evaluation loop - just a set of instructions. The topmost instruction is executed in each expression in the program, and its result is not evaluated any further. Thus, returned eval will be the final result:


!(pragma! interpreter bare-minimal) ; ()
(= (foo) (eval (bar)))
(= (bar) a)
!(eval (foo)) ; (eval (bar))
Output
[()]
[(eval (bar))]
A special instruction (chain ARG $VAR RESULT) in Minimal MeTTa is used to execute one instruction (ARG), bind $VAR (which should be a variable) to its result, and substitute $VAR inside RESULT which is returned after substitution:


!(pragma! interpreter bare-minimal)
!(eval (result is (+ 1 2))) ; NotReducible
!(chain (eval (+ 1 2)) $x (result is $x)) ; (result is 3)
!(eval (+ 1 (+ 2 3))) ; NotReducible
!(chain (eval (+ 2 3)) $x (eval (+ 1 $x))) ; 6
Output
[()]
[NotReducible]
[(result is 3)]
[NotReducible]
[6]
chain can be used to continue evaluation of a function, which returns eval:


!(pragma! interpreter bare-minimal) ; ()
(= (foo) (eval (bar)))
(= (bar) a)
!(chain (eval (foo)) $x $x) ; a
Output
[()]
[a]
This example explicitly shows that chain not just returns its last argument (after substitution), but executes it in contrast to eval.

In Minimal MeTTa, arguments are always passed by eval to functions without changes, and subexpressions will never be evaluated. If one wants to construct a (possibly unreducible) expression by evaluating its subexpression, or to first evaluate a subexpression and then the whole expression, then it is necessary to use chain with this subexpression as ARG as shown in the example above. The MeTTa interpreter does this work - it traverses subexpressions and chains their evaluation keeping non-reducible (sub)expressions as is:


!(result is (+ 1 (+ 2 3))) ; (result is 6)
Output
[(result is 6)]
Let us consider a few more examples in Minimal MeTTa:


!(pragma! interpreter bare-minimal)
(= (foo) (bar))
(= (bar) a)
(= (buz $x) ($x $x))
!(chain (eval (foo)) $x (result is $x)) ; (result is (bar))
!(chain (eval (foo)) $x (eval $x)) ; a
!(chain (eval (foo)) $x (eval (buz $x))) ; ((bar) (bar))
!(chain (foo) $x (buz $x)) ; (buz (foo))
Output
[()]
[(result is (bar))]
[a]
[((bar) (bar))]
[(buz (foo))]
Apparently, if we perform only one step of evaluation of the function argument, this argument can remain not fully reduced. The only functionality provided by chain is to substitute the result of execution of one atom to another atom, and try to execute the result of substitution (which will be executed if it is a Minimal MeTTa instruction).

chain can be used in MeTTa instead of let if a Minimal MeTTa instruction (such as eval or unify) should be executed first. For example, let returns Empty, when the result of unification of its two arguments is empty, while chain still returns its last argument with substitutions, which may or may not be further reduced to Empty:


(= (id-eq $x $x) $x)
(= (id-eq $x $y) Empty)
!(let $r (id-eq 1 2) (quote $r)) ; []
!(let $r (eval (id-eq 1 2)) (quote $r)) ; []
!(chain (eval (id-eq 1 2)) $r (quote $r)) ; [(quote Empty)]
!(chain (eval (id-eq 1 2)) $r (it is $r)) ; []
Output
[]
[]
[(quote Empty)]
[]
quote has Atom as its argument type, so this argument is not evaluated. That is why (quote Empty) is a possible expression. However, in case of let this expression is simply not constructed. In case of chain, (it is Empty) is constructed but reduced to no result by the interpreter, because the whole tuple doesn't exist if one of its elements doesn't exist.

Calculations in a loop: function/return
In principle, eval, unify and chain are enough to implement recursion with arbitrary depth, but it may require more chains than expected:


!(pragma! interpreter bare-minimal)
(= (div $x $y $accum)
   (chain (eval (- $x $y)) $r1
     (chain (eval (< $r1 0)) $r2
       (chain (unify $r2 True
         $accum
         (chain (eval (+ 1 $accum)) $inc
           (chain (eval (div $r1 $y $inc)) $r4 $r4)
         )) $r3 $r3
       )
     )
   )
)
!(chain (eval (div 35 5 0)) $rr $rr) ; 7
Output
[()]
[7]
We will not analyze this program in detail - just notice the number of chains in it. Minimal MeTTa introduces a pair of instructions - function and return. (function CODE) evaluates CODE (and its result) until encounters (return RESULT), after which it terminates and returns RESULT:


!(pragma! interpreter bare-minimal)
(= (foo) (eval (bar)))
(= (bar) (eval (baz)))
(= (baz) (return a))
(= (fooo) (function (eval (foo))))

!(function (eval (foo))) ; a
!(eval (fooo)) ; a
Output
[()]
[a]
[a]
Let us consider the div example. With function and return, there will be two chains less:


!(pragma! interpreter bare-minimal)
(= (div $x $y $accum)
   (chain (eval (- $x $y)) $r1
     (chain (eval (< $r1 0)) $r2
       (unify $r2 True
         (return $accum)
         (chain (eval (+ 1 $accum)) $inc
           (eval (div $r1 $y $inc))
         )
       )
     )
   )
)
!(function (eval (div 35 5 0))) ; 7
Output
[()]
[7]
We still need to chain arithmetic calculations, so the profit seems not that big. However, the code looks more natural - we don't need to explicitly put the results of unify and eval inside chain and guess, how many additional steps of evaluation should be done.

function expects (return RESULT) expression, and if it encounters something else, which is not an executable Minimal MeTTa instruction, it return an error (; can be removed to see other error messages):

!(pragma! interpreter bare-minimal)
(= (foo) (eval (boo)))
(= (boo) (eval (goo)))
(= (goo) G)

; !(function (A)); (Error (A) NoReturn)
; !(function (eval A)) ; (Error NotReducible NoReturn)
!(function (eval (foo))) ; (Error G NoReturn)

Output
[()]
[(Error G NoReturn)]
In the last expression, (eval (foo)) is evaluated by function until (eval goo) returns G, which is wrapped into Error.

An interesting feature of function is that it is treated by Minimal MeTTa in a special way. Unlike other instructions, it is executed even if it is a result of another instruction (not an argument of eval or chain). In the example below, eval and chain remain unreduced after being returned by (eval (foo)) and (eval (boo)) correspondingly, while function returned by (eval (goo)) is evaluated:


!(pragma! interpreter bare-minimal)
(= (foo) (eval (+ 1 2)))
(= (boo) (chain (eval (+ 1 2)) $r $r))
(= (goo) (function (chain (eval (+ 1 2)) $r (return $r))))
! (eval (foo)) ; (eval (+ 1 2))
! (eval (boo)) ; (chain (eval (+ 1 2)) $r#nn $r#nn)
! (eval (goo)) ; 3
Output
[()]
[(eval (+ 1 2))]
[(chain (eval (+ 1 2)) $r#17022 $r#17022)]
[3]
collapse-bind and superpose-bind
collapse-bind and superpose-bind differ from collapse and superpose functions from stdlib in that they store not only atoms, but also bindings (values) of variables.

For example, collapse-bind can collect results of branches, in which the value of variable $a is different. superpose-bind applied to the result of collapse-bind will restore the value of this variable in each context. That's why collapse-bind returns and superpose-bind accepts not the list of atoms, but the list of pairs (ATOM BINDING), where BINDING is a special grounded atom. In the following example, we have a nondeterministic function xoo. collapse-bind converts its results to a list of results with bindings.


!(pragma! interpreter bare-minimal)
(= (xoo a) xa)
(= (xoo b) xb)

!(chain
  (collapse-bind (eval (xoo $a))) $c
  ($c $a)) ; (((xb { $a <- b }) (xa { $a <- a })) $a)

!(chain
   (collapse-bind (eval (xoo $a))) $c
   (chain
     (superpose-bind $c) $x
     ($x $a))) ; [(xa a), (xb b)]
Output
[()]
[(((xb { $a <- b }) (xa { $a <- a })) $a)]
[(xa a), (xb b)]
chain is used here to extract bindings of $a into the external context (i.e., to construct ($x $a)).

collapse-bind is similar to chain in that it executes Minimal MeTTa instructions to collect the result.

cons-atom and decons-atom
cons-atom constructs an expression given its head and tail, while decons-atom separates an expression into its head and tail, and returns them as a pair. decons-atom expects a non-empty expression.


!(cons-atom a (b c)) ; (a b c)
!(decons-atom (a b c)) ; (a (b c))
!(decons-atom (a)) ; (a ())
!(decons-atom ()) ; (Error (decons-atom ()) expected: (decons-atom (: <expr> Expression)), found: (decons-atom ()))
Output
[(a b c)]
[(a (b c))]
[(a ())]
[(Error (decons-atom ()) expected: (decons-atom (: <expr> Expression)), found: (decons-atom ()))]
